<!DOCTYPE html>
<!-- saved from url=(0074)https://gradeit.cs.washington.edu/uwcse/scoresheet/143/19au/DC/juntiw3/a4/ -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Grade-It - Score Report: 143 19au a4 DC JUNTIW3</title>
    

    
        <meta http-equiv="Cache-Control" content="no-cache">
        <meta http-equiv="Pragma" content="no-cache">
        <meta http-equiv="Expires" content="0">

    
            <style type="text/css">
                a, .buttonlink, input[type="submit"], input[type="reset"], input[type="button"], button {
	color: #A30;
	text-decoration: none;
}

h1 a {
	text-decoration: underline;
}

a.white {
	color: #ffffff;
}

a:hover, input[type="submit"]:hover, input[type="reset"]:hover, input[type="button"]:hover, button:hover {
	background-color: #FFFF99;
	cursor: pointer;
	text-decoration: underline;
}

a img {
	border-width: 0;
}

ul.studentinfo {
	list-style-type: none;
	padding-left: 2em;
}

.aside {
	color: #666666;
	font-weight: normal;
	font-size: smaller;
}

.assignmentslist, .assignmentstable {
	margin-left: auto;
	margin-right: auto;
}

.assignmentslist li {
	display: inline;
	font-family: "Trebuchet MS", "Helvetica", "Arial", sans-serif;
	font-size: 200%;
	margin-right: 1.1em;
}

body, input, select, option, button {
	/* I know I set this black color for some reason, but I can't recall... */
	/* color: black; */
	font-family: "Candara", "Trebuchet MS", "Verdana", "Geneva", "Helvetica", "Arial", sans-serif;
	font-size: 11pt;
}

body {
	background-color: white;
/*
	margin: 0px;
	padding: 0px;
*/
}

body, html {
/*
	height: 100%;
*/
}

/*
fieldset * {
	vertical-align: top;
}
*/

.buttonlink, input[type="submit"], input[type="reset"], input[type="button"], button {
	background-color: #CCCCCC;
	border: 2px solid gray;
	border-left: 2px solid #DDDDDD;
	border-top: 2px solid #DDDDDD;
	border-radius: 4px;
	-moz-border-radius: 4px;
	-webkit-border-radius: 4px;
	margin-right: 0.2em;
	padding: 0.25em 0.5em;
	white-space: nowrap;
}

.code {
	font-family: "Consolas", "Courier New", monospace;
	white-space: pre;
}

#copypreviousform {
	width: 18em;
}

.copyfromquarterarea, #quarterlistarea {
	display: inline;
}

.courselist {
	font-size: large;
	line-height: 3.5em;
	list-style-type: none;
	margin: 0em;
	margin-top: 0.5em;
	margin-bottom: 0.5em;
	padding: 0em;
}

.courselist label {
	float: left;
	width: 8em;
	max-width: 10em;
}

.courselist li {
	clear: both;
	margin-left: 1em;
	margin-right: 1em;
}

.courselist a {
	padding-left: 0.8em;
	padding-right: 0.8em;
	padding-top: 0.2em;
	padding-bottom: 0.2em;
}

#debugheader {
	border-width: 2px;
	font-weight: bold;
	left: 20em;
	position: absolute;
	width: 10em;
}

.detailedlist {
	width: 50%;
}

#dumptarget {
	background-color: #dfd;
	border: thin solid green;
	display: none;
	overflow: auto;
	font-family: "Candara", "Trebuchet MS", "Verdana", "Helvetica", "Arial", sans-serif;
	margin: 1em;
	padding: 0.5em;
	white-space: pre;
}

.explanation {
	margin-left: 1em;
}

.gradedcolumn {
	text-align: center;
}

h1 {
	margin-top: 0px;
	padding-top: 0px;
	font-size: 16pt;
	text-align: center;
	line-height: 1.1em;
	padding-bottom: 10px;
}

h2 {
	font-size: 14pt;
	margin-top: 18px;
	clear: both;
}

h3 {
	margin: 0px;
	text-align: center;
}

h1,h2 {
	font-family: "Candara", "Trebuchet MS", "Helvetica", "Arial", sans-serif;
	margin-bottom: 0px;
}

.helptips {
	background-color: #FFFFEE;
	background-image: url("images/question-mark-yellow.gif");
	background-repeat: no-repeat;
	background-position: 100% 0%;
	border: 1px solid #DDDD77;
	padding: 0em 1em;
	margin: 1.5em 3em;
	border-radius: 5px;
	-moz-border-radius: 5px;
	-webkit-border-radius: 5px;
}

.helptips p {
	padding-right: 48px;
}

img.icon {
	width: 16px;
	height: 16px;
	vertical-align: middle;
}

img.iconlarge {
	width: 32px;
	height: 32px;
	vertical-align: middle;
}

img.imageicon {
	width: 48px;
	height: 48px;
}

input#student[type="text"] {
	background-color: white;
}

/* for elements that fail JS form validation */
.invalid {
	background-color: #ffff00 !important;
}

.mainheader {
	
}

#messagepane {
	background-color: #F8F8F8;
	border: 8px solid;
	border-top-color: #EEEEDD;
	border-left-color: #EEEEDD;
	border-bottom-color: #CCCCBB;
	border-right-color: #CCCCBB;
	height: 60%;
	left: 20%;
	overflow: scroll;
	padding: 1em;
	position: fixed;
	_position: absolute;
	top: 20%;
	width: 60%;
}

.messagepanetall {
	height: 90% !important;
	left: 4% !important;
	top: 2% !important;
	width: 92% !important;
}

#messagepaneclosearea {
	position: absolute;
	right: 0.25em;
	top: 0.5em;
}

#nextlink, #previouslink {
	background-color: #eeeeee;
	border: thin solid #cccccc;
	line-height: 1em;
	margin: 0em;
	padding: 0.1em 0.5em 0.1em 0.5em;  /* top right bottom left */
	position: absolute;
	text-decoration: none !important;
	top: 0em;
}

.nextlink2, .previouslink2 {
	top: 1.5em !important;
}

#nextlink {
	right: 0em;
	border-radius: 0px 0px 0px 12px;
	-moz-border-radius: 0px 0px 0px 12px;
	-webkit-border-radius: 0px 0px 0px 12px;
}

#pagecover, .pagecover {
	position: fixed;
	width: 100%;
	height: 90%;
	left: 0%;
	bottom: 0%;
	background-color: rgba(230, 230, 255, 0.5);
	text-align: center;
	padding-top: 40%;
}

#previouslink {
	left: 0em;
	border-radius: 0px 0px 12px 0px;
	-moz-border-radius: 0px 0px 12px 0px;
	-webkit-border-radius: 0px 0px 12px 0px;
}

pre, code, tt, xmp, #homeworkeditarea {
	font-family: "Consolas", "Courier New", monospace;
	font-size: 9pt;
	line-height: 1.05em;
}

pre {
	margin-top: 5px;
}

p {
	margin-bottom: 8px;
	margin-top: 8px;
/*	text-align: justify; */
	page-break-inside: avoid;
}

.resultinprogress {
	color: #AAAA00;
}

.resultincomplete {
	color: #AA0000;
}

.resourcesarea {
/*
	margin-top: 2em;
*/
 	margin-top: 0.5em;
 	border: none;
}

.statstable {
	border: 1px solid black;
	border-collapse: collapse;
	margin-left: auto;
	margin-right: auto;
	margin-top: 1em;
}

.statstable td, .statstable th {
	border: 1px solid black;
	padding: 2pt;
}

.statstable .statscell {
	vertical-align: bottom;
	white-space: nowrap;
}

table {
	margin: 0px;
	padding: 0px;
	border-width: 0px;
	color: #000000;
}

table.maindatatable th {
	padding-right: 3em;
	text-align: left;
	vertical-align: top;
}

td,th {
	vertical-align: top;
}

td.spaced {
	padding-right: 20px;
}

textarea, input[type="text"], input[type="file"] {
/*
	background-color: inherit;
*/
}

textarea {
	font-size: 12pt;
}

ul {
	/* margin-top: 3px; */
}

.diffframe {
	border: none;
	min-height: 10%;
	width: 99%;
}

.errormessage {
	font-family: "Candara", "Trebuchet MS", "Verdana", "Geneva", "Helvetica", "Arial", sans-serif;
	font-size: larger;
	font-weight: bold;
	white-space: normal;
}

.errormessage, #dumptarget.errordump {
	background-color: #FFFFCC;
	border: 2px solid #990000;
	color: #990000;
}

.errormessage, .warningmessage {
	font-style: italic;
	margin: 0.5em;
	padding: 0.25em;
	text-align: center;
	border-radius: 4px;
}

.grades {
	padding-right: 50px;
}

.hoveringtoolsarea {
	background-color: white;
	border: 2px solid black;
	font-size: 10pt;
	padding: 3px;
	position: fixed;
	_position: absolute;  /* IE6 hack */
	right: 0px;
	bottom: 0px;
	text-align: right;
	z-index: 3;
}

#loading {
	background-color: #990000;
	color: white;
	margin: 0px;
	padding: 5px;
	position: fixed;
	_position: absolute;
	right: 0px;
	top: 0px;
	visibility: hidden;
}

.publishedscore {
	white-space: pre;
}

.secondcolumn {
	float: right;
}

.spacedrow th, .spacedrow td {
	padding-top: 2em;
}

.alltasarea {
	line-height: 55px;
}

.tabox {
	font-size: larger;
	white-space: nowrap;
}

.tabox a {
	padding-top: 24px;
	padding-right: 0.5em;
}

.closearea {
	bottom: 1%;
	right: 0%;
	position: fixed;
	text-align: right;
/*	width: 100%;	*/
}

.closearea * {
	vertical-align: bottom;
}

.closearea button {
	padding-bottom: 0.5em;
	padding-left: 2em;
	padding-right: 2em;
	padding-top: 0.5em;
}

.tooltip {
	background-color: #FFFFAA;
	border: 1px solid #999999;
	margin: 0.5em;
}

.warningmessage {
	background-color: #FFFFCC;
	border: thin solid #999900;
	color: #999900;
}

#chatboxarea {
	position: fixed;
	right: 0;
	bottom: 0;
	background: white;
	border: 1px solid gray;
}

#chatboxheader {
	text-align: center;
}

li.consistencyitem {
	margin-bottom: 1.5em;
}

.latedaytable {
	text-align: center;
}

.latedaytable td {
	padding: 0.5em 1em 0em 0.5em;
}
            </style>

        
            <style type="text/css">
                .annotaterfileslist {
	background-color: #EEEEEE;
	border-left: 1px solid #CCCCCC;
	border-right: 1px solid #CCCCCC;
	border-bottom: 1px solid #CCCCCC;
	-moz-border-radius: 0px 0px 10px 10px;
	text-align: left;
	list-style-type: none;
	margin-top: 0em;
	padding-bottom: 0.25em;
	padding-left: 0.2em;
	padding-right: 0.2em;
	padding-top: 0.5em;
	z-index: 9999;
}

#nextlink, #previouslink {
	height: 1em;
	overflow: hidden;
	z-index: auto;
}

#nextlink:hover, #previouslink:hover {
	overflow: visible;
	z-index: 9999;
}

.annotation, .sticker {
/*
	clear: right;
	float: right;
	margin-right: 1em;
*/
	color: black;
	display: block;
	font-family: "Candara", "Trebuchet MS", "Verdana", "Helvetica", "Arial", sans-serif;
	font-size: smaller;
	white-space: normal;
	z-index: 3;

	position: absolute;
	right: 1em;
/*

	min-width: 20%;
	width: 20%;
*/
}

.annotation {
	background-color: white;
	border: 1px dotted gray;
	font-weight: bold;
	padding: 3px;
	width: 18em;
}

.annotationcodearea {
	position: relative;
}

#clearall, #annotatecancelbutton, #undo, #annotatehidebutton, #edit {
	padding-left: 2px;
	padding-right: 2px;
/*
	width: 7em;
*/
}

#annotatehidebutton {
	padding-left: 4pt;
	padding-right: 4pt;
}

#highlightcolors {
	line-height: 14px;
}

.homeworkcodearea {
	width: 100%;
}

#homeworkcode {
	/* border: 1px solid transparent;
	_border: 1px solid white; */
	z-index: 50;
}

#homeworkcodehighlight {
	background-color: transparent;
	/* border: 1px solid white; */
	z-index: 60;
}

#homeworkcodeoverlay {
	background-color: transparent;
	color: transparent;
	/* border: 1px solid #F0F0F0; */
	z-index: 70;
}

#homeworkcode, #homeworkcodeoverlay, #homeworkcodehighlight {
	position: absolute;
	left: 0px;
	top: 0px;
}

#homeworkcode, #homeworkcodeoverlay, #homeworkcodehighlight, .characternumbers {
	padding-left: 1em;
	padding-right: 1em;
}

#homeworkeditarea {
	height: 100%;
}

.homeworkcodeform {
	width: 99%;
	height: 80%;
}

.hoveringtoolsarea {
	z-index: 90;
}

.hoveringtoolsarea * {
	font-size: 9pt;
}

.linenumbers, .characternumbers {
	color: #AAA;
	z-index: 3;
}

.linenumbers {
	background-color: #F7F7F7;
	border: 1px solid transparent;
	_border: 1px solid white;
	max-width: 3em;
}

.maximize {
	border: 1px solid black;
	line-height: 16px;
	position: fixed;
	_position: absolute;
	right: 0em;
	top: 0em;
	vertical-align: bottom;
}

.originalcode {
	display: none;
}

del, .strikeout {
	color: red;
	text-decoration: line-through;
}

pre, code, tt, xmp {
	margin: 0px;
	white-space: pre;
}

.stickeroverlay {
	position: absolute;
/*
	left: 0px;
	top: 0px;
*/
	bottom: 5px;
	left: 2px;
}

#stickerselect {
	margin-left: 0.25em;
	max-width: 7em;
}

.studentparam, .filenameparam, .editurl {
	display: none;
}

.tablecodecell {
	width: 99%;
}

.annotationpopup {
	background-color: white;
	border: thin solid gray;
	border-radius: 15px;
	-moz-border-radius: 15px;
	-webkit-border-radius: 15px;
	max-height: 10em;
	position: absolute;
	text-align: center;
	width: 24em;
	z-index: 99999;
}

.annotationpopup legend {
	background-color: white;
	border-radius: 5px;
	-moz-border-radius: 5px;
	-webkit-border-radius: 5px;
	border: thin solid #999;
	padding: 3px 8px;
}

#annotationpopuppastannotations, #annotationpopuppastannotations option {
	max-width: 20em;
	width: 20em;
}


input[type='radio'][checked='checked'] {
	background-color: #ffffcc;
}

/* geshi styles */
#homeworkcodehighlight .imp {font-weight: bold; color: red;}
#homeworkcodehighlight li, #homeworkcodehighlight .li1 {font-weight: normal; vertical-align:top;}
#homeworkcodehighlight .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
#homeworkcodehighlight .li2 {font-weight: bold; vertical-align:top;}
#homeworkcodehighlight .kw1 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw2 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw1 {color: #708;  font-weight: bold;}
#homeworkcodehighlight .kw2 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw3 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw4 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw5 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw6 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw7 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw8 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw9 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw10 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw11 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw12 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw13 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw14 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw15 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw16 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw17 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw18 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw19 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw20 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw21 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw22 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw23 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw24 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw25 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw26 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw27 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw28 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw29 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw30 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw31 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw32 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw33 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw34 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw35 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw36 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw37 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw38 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw39 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw40 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw41 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw42 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw43 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw44 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw45 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw46 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw47 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw48 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw49 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw50 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw51 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw52 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw53 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw54 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw55 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw56 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw57 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw58 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw59 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw60 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw61 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw62 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw63 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw64 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw65 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw66 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw67 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw68 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw69 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw70 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw71 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw72 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw73 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw74 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw75 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw76 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw77 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw78 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw79 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw80 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw81 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw82 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw83 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw84 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw85 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw86 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw87 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw88 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw89 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw90 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw91 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw92 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw93 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw94 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw95 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw96 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw97 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw98 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw99 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw100 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw101 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw102 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw103 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw104 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw105 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw106 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw107 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw108 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw109 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw110 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw111 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw112 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw113 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw114 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw115 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw116 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw117 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw118 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw119 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw120 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw121 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw122 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw123 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw124 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw125 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw126 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw127 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw128 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw129 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw130 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw131 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw132 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw133 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw134 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw135 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw136 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw137 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw138 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw139 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw140 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw141 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw142 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw143 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw144 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw145 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw146 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw147 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw148 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw149 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw150 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw151 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw152 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw153 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw154 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw155 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw156 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw157 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw158 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw159 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw160 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw161 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw162 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw163 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw164 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw165 {color: #708; font-weight: bold;}
#homeworkcodehighlight .kw166 {color: #708; font-weight: bold;}
#homeworkcodehighlight .co1,
#homeworkcodehighlight .co2,
#homeworkcodehighlight .co3,
#homeworkcodehighlight .coMULTI {color: #a1a100;}

/*
#homeworkcodehighlight .co2 {color: #ff0000; font-style: italic;}
#homeworkcodehighlight .co3 {color: #008000; font-style: italic;}
#homeworkcodehighlight .coMULTI {color: #808080; font-style: italic;}
*/
#homeworkcodehighlight .es0 {color: #000099; font-weight: bold;}
#homeworkcodehighlight .es2 {color: #000099; font-weight: bold;}
#homeworkcodehighlight .br0 {color: #00AA00;}
#homeworkcodehighlight .sy0 {color: #00AA00;}
#homeworkcodehighlight .st0 {color: #aa0000;}
#homeworkcodehighlight .nu0 {color: #cc66cc;}
#homeworkcodehighlight .re0 {color: #cc00cc;}
#homeworkcodehighlight .re1 {color: #6666ff;}
#homeworkcodehighlight .re2 {color: #3333ff;}
#homeworkcodehighlight .re3 {color: #933;}
#homeworkcodehighlight .ln-xtra, #homeworkcodehighlight li.ln-xtra, #homeworkcodehighlight div.ln-xtra {background-color: #ffc;}
#homeworkcodehighlight span.xtra { display:block; }
#homeworkcodehighlight .sc-2 {color: #404040;}
#homeworkcodehighlight .sc-1 {color: #808080; font-style: italic;}
#homeworkcodehighlight .sc0 {color: #00bbdd;}
#homeworkcodehighlight .sc1 {color: #ddbb00;}
#homeworkcodehighlight .sc2 {color: #009900;}
            </style>

        
            <style type="text/css">
                body, input, select, option, button {
/*
	color: black;
*/
}

h2 {
	margin: 0em;
	padding-right: 1em;
}

input[type="text"] {
	border: 1px solid gray;
	vertical-align: baseline;
/*
	font-size: smaller;
	width: 1.5em;
	background-color: white;
*/
}

input[type="text"].categoryname {
	text-align: left;
	border: none;
}

input[type="text"].score,
input[type="text"].max,
input[type="text"].itemmax,
input[type="text"].categorymax,
input[type="text"].earlydays,
input[type="text"].latedaysused,
input[type="text"].zeromax {
	text-align: center;
	width: 2em;
}

input[type="text"].uneditabledescription,
input[type="text"].uneditablemax,
input[type="text"].uneditablename,
input[type="text"].uneditableattributetext {
	background-color: transparent;
	border: thin solid transparent;
}

input[disabled="disabled"] {
	color: black;
}

li.item, li.latenessitem {
	margin-bottom: 0.25em;
}

.commentsarea {
	text-indent: 0em;
	/* display: block; */
}

.previouscomments {
	vertical-align: top;
	/* display: none; */
	max-width: 6em;
}

.publisharea {
	margin-bottom: 10px;
	margin-top: 10px;
}

ul {
	list-style-type: none;
}

ul.category {
	font-size: 11pt;
	font-weight: normal;
}

ul#overalllist {
	font-size: 14pt;
	font-weight: bold;
	margin-left: 0px;
	margin-top: 0.5em;
	padding-left: 0em;
	list-style-type: none;
}

ul#overalllist > li.category {
	margin-bottom: 1em;
}

/*
#criteriaFields li, .max, .categorytotal {
	font-family: "Arial", sans-serif;
}
*/

.criteriafillcontrols {
	margin-top: 5px;
	margin-bottom: 5px;
}

.duetime {
/*
	padding-left: 0.5em !important;
*/
	text-align: left !important;
}

.duetime, #total {
	border: 1px solid transparent !important;
}

input[type="text"].comments,
input[type="text"].studentinfo {
	text-align: left !important;
}

input[type="text"].studentinfo {
	padding-left: 5px;
}

.comments {
	width: 95%;
	color: #000088;
	font-family: "Candara", "Trebuchet MS", "Verdana", "Geneva", "Arial", "Helvetica", sans-serif;
	font-size: 11pt;
	font-style: italic;
/*
	padding-left: 5px;
*/
	padding-right: 5px;
/*
	commenting this out because long comments need to wrap to the next line
	white-space: pre;
*/
}

.commentspy {
	color: #008800;
	font-family: "Candara", "Trebuchet MS", "Verdana", "Geneva", "Arial", "Helvetica", sans-serif;
	font-size: 11pt;
	font-style: italic;
	padding-left: 5px;
	padding-right: 5px;
	text-indent: 0em;
	/* white-space: pre; */
}

.commentspy a {
	color: #00AA00;
	text-decoration: underline;
}

.commoncomment {
	color: gray;
	font-size: smaller;
	text-indent: 0em;
}

.gradernote {
	color: #666666 !important;
	margin-bottom: 0.75em;
	margin-top: 0.25em;
	margin-left: 2em;
	padding: 0px;
	padding-left: 0em;
	text-indent: 0em;
}

.gradernote ul {
	list-style: disc;
}

.uniqueid {
	color: #999999;
	float: right;
	font-size: 9pt;
	font-weight: normal;
	letter-spacing: 0em;
	/* margin-left: 8em; */
	margin-right: 2em;
}

.zeromax {
	color: transparent;
	visibility: hidden;
}

.itemmin, .sid {
	display: none;
}

.overallcommentsarea {
	margin-top: 1.5em;	
}

#gradesdblatedaysused, #gradesdbearlydaysearned {
/*
	font-size: larger;
*/
	font-weight: bold;
}

#gradingtimer {
	/*background-color: #EEEEAA;
	border: 1px solid #BBBB66;*/
	font-weight: bold;
	padding: 2px;
	white-space: nowrap;
}

.latesubmission {
	color: #880000;
	font-weight: bold;
}

.earlysubmission {
	color: #007700;
	font-weight: bold;
}


.gradingready, .gradingnotready {
	border-width: 2px;
	border-style: dashed;
	font-weight: bold;
	margin: 0.5em;
	padding: 0.5em;
	text-align: center;
}

.gradingready {
	background-color: #eeffee;
	color: #005500;
}

.gradingnotready {
	background-color: #ffeeee;
	color: #550000;
}

/* for the un-editable criteria view */
span.categoryname, span.categorymax, span.categorytotal, .itemmax.uneditablemax, .categoryname.uneditablename {
	font-weight: bold;
}

.criteriaformwrapper {
	display: inline-block;
	vertical-align: top;
}

.gradernote.uneditablegradernote {
	display: none; /* Don't display so we can render markdown somewhere else */
}

.gradernotedisplay {
	color: #999999;
}

.criteriacontrols {
	padding: 1em;
}
            </style>

        
            <style type="text/css">
                .expectedimagearea, .actualimagearea, .diffimagearea {
/*
	position: absolute;
	left: 0px;
	top: 0px;
	height: 600px;
*/
}

.expectedimagearea, .actualimagearea {
	display: none;
}

.diffimagesarea {
	position: relative;
	left: 0px;
	top: 0px;
}

.diffinsert {
	background: #EEFFEE;
	color: #007700;
}

.diffdelete {
	background: #FFEEEE;
	color: #770000;
}

.expected {
	background-color: #FFEEEE;
}

.actual {
	background-color: #EEFFEE;
}

#comparecell {
	text-align: center;
}

.expectedtext, .actualtext, .diff {
	margin-right: 1em;
	width: 99%;
	max-width: 80em;
	/* height: 99%; */
}

#diffarea {
	/* height: 99%; */
}

.gradernote {
	border: thin solid #ffccff;
	background-color: #ffeeff;
	font-style: italic;
	margin: 0.5em 1.5em;
	padding: 0.5em 1em;
	
}

h3 {
	font-weight: normal;
	text-align: left;
	margin-bottom: 1em;
	margin-top: 0.5em;
}

.maximize {
	border: 1px solid black;
	line-height: 16px;
	position: fixed;
	_position: absolute;
	right: 0em;
	top: 0em;
	vertical-align: bottom;
}

.maximize img {
	vertical-align: bottom;
}

table.difftable {
	width: 99%;
	/* height: 99%; */
}

table.difftable td, table.difftable th {
	vertical-align: top;
}

table.difftable th {
	text-align: left;
}

table.difftable td a, table.difftable th a {
	text-decoration: underline;
}

.nottall {
	height: 2em;
}

/*
table.difftable td.output, table.difftable td.output textarea {
	width: 99%;
	height: 99%;
}
*/

td.output {
	width: 50%;
}


/* stuff for HTML diffing */
.sliderarea {
	background-color: white;
	border-bottom: 2px solid black;
	height: 28px;
}

.htmldiffarea {
	height: 120em;
	position: relative;
	overflow: hidden;
}

.expectedhtml, .actualhtml {
	border: 0px;
	height: 120em;
	left: 0px;
	margin: 0px;
	padding: 0px;
	position: absolute;
	top: 30px;
	width: 100%;
}

.expectedhtml {
	opacity: 0.999;
}

.actualhtml {
	opacity: 0.001;
}

.slider-bg {
	position: relative;
	background: url(../img/bg-fader.gif) 5px 0 no-repeat;
	height: 28px;
	width: 228px;
	float: left;
	margin-left: 1em;
}

.slider-thumb {
	position: absolute;
	top: 4px;
}

.locksliderlocked {
	position: fixed;
	left: 0px;
	top: 0px;
	z-index: 99999;
	border: 2px solid gray;
}

            </style>

        
            <style type="text/css">
                .annotationtable {
	width: 99%;
}

.comments {
	white-space: normal;
}

div.filearea {
	page-break-after: always;
}

fieldset {
	border: none;
}

#homeworkcode {
	position: static !important;
}

#homeworkcode, #homeworkcodeoverlay, .homeworkcode, .homeworkcodeoverlay {
	/* width: 99%; */
}

/* #homeworkcodeoverlay, */
.hoveringtoolsarea,
#savebutton, 
#cancelbutton,
#scoresheetcancelbutton,
#scoresheetdeletebutton,
#scoresheetsavebutton,
.commentspylink,
.commentspyspace,
.criteriacontrols,
.criteriafillcontrols,
.tooltip,
.diffcontrolsarea,
.gradernote,
.imagelabel,
.addcommentlink,
.blankspace,
.posttogradesdbarea,
.publisharea,
#previouslink,
#nextlink,
.warningmessage,
.errormessage,
.previouscomments
{
	display: none !important;
}

input[type="text"].score,
input[type="text"].latedaysused,
input[type="text"].earlydays,
input[type="text"].studentinfo {
	border: none;
}
            </style>

        
            <style type="text/css">
                .fail, .pass {
	font-size: larger;
	font-weight: bold;
	margin-top: 0em;
}

.fail {
	color: #600;
	margin: 2px;
}

.faildramatic {
	color: #C00 !important;
}

.lesscoloredlink {
	color: #772200 !important;
}

hr {
	clear: both;
	margin: 2px;
}

.linenumber {
	color: #666666;
	font-style: italic;
}

.pass {
	color: #070;
	margin: 2px;
}

.testcase h2 {
	margin: 0em;
	margin-right: 1em;
}

.testcase.collapsed:hover {
	background-color: #FFFFBB;
}

.testcasebody {
	padding-left: 1em;
}

.collapsed h2 {
	float: left;
	min-width: 60%;
}

.stylecheckarea {
	margin-bottom: 1em;
	/* padding-left: 1em; */
}

.swffieldset {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
	padding: 0px;
	text-align: center;
	background-color: #ddd;
}

.swffieldset legend {
	background-color: white;
	border: thin solid #CCCCCC;
	margin-left: 1em;
	padding: 0.1em 0.4em;
}

.validatorform {
	display: inline;
	padding-left: 0.3em;
	padding-right: 0.3em;
}

.turninwebsterdiffs {
	margin-left: 2em;
	padding: 0.2em;
	border: thin dotted #77A;
}

.withtooltip {
	border-bottom: 1px dotted gray;
}

/* some w3c validator stuff to hide */
p.helpwanted, p.backtop, ul#menu.navbar, div#footer {
	display: none;
}

/* stolen W3C styles */
.w3cerrors {
	color: #1F2126;
	font-family: Helvetica, Arial, Sans-Serif;
	font-size: 100%;
	font-style: normal;
	font-weight: normal;
	margin-left: 2em;
	margin-right: 0.5em;
	text-align: left;
}

.w3cerrors td, .w3cerrors th {
	padding: 6px;
}


.w3cerrors td.linenumber {
	background-color:#E1E1E1;
	border-bottom:1px solid #CCCCCC !important;
	text-align:right;
	width:3em;
}

.w3cerrors table {
	border-collapse: collapse;
	line-height: 120%;
	border-right:1px solid #CCCCCC;
	border-top:1px solid #CCCCCC !important;
	line-height:120%;
	width: 100%;
	margin-bottom: 1em;
}

.w3cerrors h2 {
  background-color: #E82848 !important;
  color: white;
}

.w3cerrors h3 {
	background-color: #D23D24 !important;
	border-color:black;
	border-bottom:1px dotted #AAAA77;
	color: white;
	font-family:"Bitstream Vera Sans",Verdana,Arial,sans-serif;
	font-style:normal;
	font-weight:800;
	font-size:1.1em;
	letter-spacing:normal;
	margin:0;
	padding:0.4em;
}

.w3cerrors td.parse-error {
	padding: 5px 1em;
	border-bottom: 1px solid #fdd !important;
}

.w3cerrors td.nocontext {
	width: 3em;
	border-bottom: 1px solid #ddd !important;
	background-color: #F1F1F1;
}

.w3cerrors td.codeContext {
	background-color: #F1F1F1;
	border-bottom: 1px solid #DDDDDD !important;
}

.w3cerrors td.io,
.w3cerrors td.notfound,
.w3cerrors td.invalidparam,
.w3cerrors td.errortoken,
.w3cerrors td.unknownerror {
	padding: 5px 1em;
	border-bottom: 1px solid #fdd !important;
}

.w3cerrors tr.warning {
	padding: 0;}

.w3cerrors td.level1, .w3cerrors td.level2, .w3cerrors td.level0 {
	padding: 5px 1em;
	border-bottom: 1px solid #fdd !important;
}
.w3cerrors .level0 {
	border-left: 10px solid #C66 !important;
	color: #000;}

.w3cerrors .level1 {
	border-left: 10px solid #FA9084 !important;
	color: #000;
}
.w3cerrors .level2 {
	border-left: 10px solid #FFB1A7 !important;
	color: #000;
}
            </style>

        
            <style type="text/css">
                .callout,.alert-box{position:relative;margin:0 0 1rem 0;padding:1rem;border:1px solid rgba(10,10,10,0.25);border-radius:0;background-color:#fff;color:#0a0a0a}.callout>:first-child,.alert-box>:first-child{margin-top:0}.callout>:last-child,.alert-box>:last-child{margin-bottom:0}.callout.primary,.primary.alert-box{background-color:#ffdbcd;color:#0a0a0a}.callout.secondary,.secondary.alert-box{background-color:#f9f9f9;color:#0a0a0a}.callout.success,.success.alert-box{background-color:#e1faea;color:#0a0a0a}.callout.warning,.warning.alert-box{background-color:#fff3d9;color:#0a0a0a}.callout.alert,.alert.alert-box{background-color:#f7e4e1;color:#0a0a0a}.callout.small,.small.alert-box{padding-top:.5rem;padding-right:.5rem;padding-bottom:.5rem;padding-left:.5rem}.callout.large,.large.alert-box{padding-top:3rem;padding-right:3rem;padding-bottom:3rem;padding-left:3rem}.alert-close-button{position:absolute;color:#8a8a8a;cursor:pointer;background-color:transparent;border:none;margin:0 !important;padding:0 !important}[data-whatinput='mouse'] .alert-close-button{outline:0}.alert-close-button:hover,.alert-close-button:focus{color:#0a0a0a}.alert-close-button:hover{background-color:transparent !important}.alert-close-button.small{right:.66rem;top:.33em;font-size:1.5em;line-height:1}.alert-close-button,.alert-close-button.medium{right:1rem;top:.5rem;font-size:2em;line-height:1}
/*# sourceMappingURL=legacy.min.css.map */
            </style>

        
                <style type="text/css" media="print">
                    pre, code, tt, xmp {
	font-size: 8pt;
}

.tooltip, .errormessage, .hoveringtoolsarea {
	display: none;
}
                </style>

            
                <style type="text/css" media="print">
                    #hoveringtoolsarea, #homeworkcodeoverlay, .homeworkcodeoverlay {
	display: none;
}

#homeworkcode, #homeworktextarea, .stickeroverlay {
	position: static !important;
}

#homeworkcodeoverlay, .homeworkcodeoverlay {
	display: none;
}                </style>

            
                <style type="text/css" media="print">
                    .narrow { letter-spacing: -0.02em; }
.verynarrow { letter-spacing: -0.15em; }
.tall { line-height: 1.05em; }
.longcode { font-size: smaller; }

ul.category, input, select, option, textarea {
	font-size: 10pt;
}

input[type="text"] {
	border: 1px solid transparent;
}

.comments {
	white-space: normal;
}

.criteriacontrols,
.criteriacontrols *,
.criteriafillcontrols,
.criteriafillcontrols *,
#savebutton,
#cancelbutton,
#scoresheetcancelbutton,
#scoresheetdeletebutton,
#scoresheetsavebutton,
.gradernote,
.addcommentlink,
.addcategory,
.addgradernoteslink,
.additem,
.attributeslink,
.categoryexpand,
.commentspylink,
.delete,
.publisharea,
.posttogradesdbarea,
.helptips,
.attributetext,
.latedayremindernote,
.commoncomment {
	display: none;
}                </style>

            
                <style type="text/css" media="print">
                    .expectedtext, .actualtext, .diff {
	width: 99%;
	font-size: 9pt;
}

.diffcontrolsarea,
.imagelabel,
.pass,
.fail {
	display: none;
}
                </style>

            
                <style type="text/css" media="print">
                    #printviewclosebutton {
	display: none !important;
}
                </style>

            
    <script>
                        if (typeof(GradeIt) === "undefined") {
            function GradeIt() {}
        }
        GradeIt.BASE_PATH = "https://gradeit.cs.washington.edu/uwcse";
        GradeIt.ANNOTATION_XML_FILE = "annotations.xml";
    </script>

    
            <script type="text/javascript">
                <!-- jsfile = annotate_common.js -->
                // JS code shared by both the annotate and the printview pages
// (which potentially shows multiple annotation pages).

// Annotations class to store data about one student's annotations on the page.
function Annotations(codeText, wrappedCodeText, escapedCodeText) {
    // original student code, without any annotations
    this.codeText = codeText.replace(/\r/g, "");
    this.wrappedCodeText = wrappedCodeText.replace(/\r/g, "");

    // student code with annotations
    this.newCodeText = this.escapedCodeText = escapedCodeText.replace(/\r/g, "");

    this.annotationList = [];  // list of all annotations

    this.insertionList = [];   // list of {cleanIndex, length} text that's been inserted
    this.undoStack = [];  // actions that have been taken, in order of insertion (for undo)

    this.wrapInsertionList = [];            //
    this.htmlEntitiesInsertionList = [];    // initial insertion list that just contains the HTML entity encoding

    this.selectedAnnotation = null;
    this.onchange = null;      // an event for notifying other code that the text has changed
    this.lineNumberMap = [];   // map of [character index => line number]

    this.buildLineNumberMap();
    this.processWrappedLines();
    this.processHtmlEntities();  // counts chars added by e.g. &lt; ,
                                 // shouldn't be called by resetCodeText
}

Annotations.ANNOTATION_PAGE = "annotation_operations.php";   // page to contact when adding annotations
Annotations.MAX_UNDO_SNAPSHOTS = 4;  // how many snapshot states should I store?  More => slower

/** Adds the given annotation. */
Annotations.prototype.add = function(annotation, skipRebuild) {
    if (skipRebuild) {   // used when bulk loading from XML (don't rebuild each add)
        this.annotationList.push(annotation);
        // this.notify();
    } else {
        // redisplay ALL annotations
        this.takeUndoSnapshot();
        annotation.isNew = true;
        this.annotationList.push(annotation);
        this.rebuildHtml();   // calls notify()
        annotation.isNew = false;
    }
};

// private helper; converts an annotation into the HTML needed
// to display it, and draws it onscreen
Annotations.prototype.addToHtml = function(annotation) {
    var beforeText = "<span id=\"" + annotation.id + "\"";
    var afterText = "";
    if (annotation.type == "annotation") {
        // var lineNumber = this.lineNumberFor(annotation.start);
        var color = (annotation.color) ? annotation.color : "white";
        beforeText += " class=\"annotation\" style=\"background-color: " + color + ";\">" + annotation.text.htmlEncode(true) + "</span>";
    } else if (annotation.type == "highlight") {
        // beforeText += " class=\"highlight\" color=" + annotation.color + " style=\"background-color: " + annotation.color + ";\">";
        beforeText += " class=\"highlight\" style=\"background-color: " + annotation.color + ";\">";
        afterText = "</span>";
    } else if (annotation.type == "strikeout") {
        beforeText += " class=\"strikeout\">";
        afterText = "</span>";
    } else if (annotation.type == "sticker") {
        var sizeText = "";
        if (annotation.width && annotation.height) {
            sizeText = " width=\"" + annotation.width + "\" height=\"" + annotation.height + "\"";
        }
        beforeText += " class=\"sticker\"><img class=\"stickerimage\" src=\"" + annotation.text + "\"" + sizeText + " /></span>";
    }

    // fix for the fact that IE6 sucks and removes quotes on inserted innerHTML,
    // which would make my length computations be off
    if (Browser.isIE()) {
        beforeText = beforeText.replace(/(class|id)=\"([^\"]+)\"/g, "$1=$2");
    }

    // add the annotation text to the proper onscreen element
    // (highlights/strikeouts are added to the homeworkcode pre block;
    // annotations/stickers are added to the linenumbers block because of its high z-order)
    if (false && (annotation.type == "annotation" || annotation.type == "sticker")) {
        // var lineNumber = this.lineNumberFor(annotation.start);
        // lineNumbers[lineNumber] += beforeText + afterText;
    } else {
        var dirtyStart = this.getDirtyStartIndex(annotation.start);
        var dirtyEnd = Math.max(dirtyStart, this.getDirtyEndIndex(annotation.end));

        var before = this.newCodeText.substring(0, dirtyStart);
        var during = this.newCodeText.substring(dirtyStart, dirtyEnd);
        var after = this.newCodeText.substring(dirtyEnd);

        if (GradeIt.debugMode()) {
            Page.dump("start = " + annotation.start +
                    "\nend = " + annotation.end +
                    "\ndirtyStart = " + dirtyStart +
                    "\ndirtyEnd = " + dirtyEnd +
                    // "\nbefore = '" + before +
                    "'\nduring = '" + during +
                    // "'\nafter = '" + after +
                    "'\n", false, true);
            Page.dump(this.insertionList, true, true);
        }

        this.newCodeText = before + beforeText + during + afterText + after;

        // add in sorted order
        var insertStart = {
            index : annotation.start,
            length : beforeText.length,
            id : annotation.id,
            type : "start",
            toString: insertionToString
        };
        this.addToInsertionList(insertStart);

        if (afterText.length > 0) {
            var insertEnd = {
                index : annotation.end,
                length : afterText.length,
                id : annotation.id,
                type : "end",
                toString: insertionToString
            };
            this.addToInsertionList(insertEnd);
        }
    }

    // this.notify();
    // return annotation.id;
};

// "private" helper
Annotations.prototype.addToInsertionList = function(obj, htmlEntity, wrap) {
    // add in sorted order
    this.insertionList.push(obj);
    this.insertionList.sort(function(a, b) { return a.index - b.index; });

    if (htmlEntity) {
        this.htmlEntitiesInsertionList.push(obj);
        this.htmlEntitiesInsertionList.sort(function(a, b) { return a.index - b.index; });
    }

    if (wrap) {
        this.wrapInsertionList.push(obj);
    }
};

// attaches various event handlers to each annotation (sticker resize, etc.)
Annotations.prototype.attachEventHandlers = function() {
    for (var i = 0; i < this.annotationList.length; i++) {
        var annotation = this.annotationList[i];
        if (annotation.type == "annotation" || annotation.type == "sticker") {
            var element = annotation.getDomElement();
            Test.assert(element, "annotations/stickers must be associated with a DOM element but was " + element);

            if (!element.onmousedown) {
                element.onclick = annotationClick;
                element.onmousemove = doEnabling;
                element.oncontextmenu = function(event) {
                    event = event || window.event;
                    if (event.stopPropagation) {
                        event.stopPropagation();
                    }
                    if (event.preventDefault) {
                        event.preventDefault();
                    }
                    event.cancelBubble = true;
                    return false;
                };

                element.title = "Choose 'Select' and click to move down; Ctrl-click to move up.  Choose 'Annotate' and click to change text.";

                // also attach the onclick handler to any children (e.g. sticker image)
                if (element.childNodes) {
                    for (var j = 0; j < element.childNodes.length; j++) {
                        if (element.childNodes[j].nodeName != "#text") {
                            if (!element.childNodes[j].onclick) {
                                element.childNodes[j].onmousemove = doEnabling;
                            }
                        }
                    }
                }
            }

            var desiredX = /*$("homeworkcodeoverlay").screenX +*/ $("homeworkcodeoverlay").clientWidth;
            if (element.style) {
                element.style.left = desiredX + "px";
            }

            // attach resizer to sticker
            if (annotation.type == "sticker") {
                /*
                var resizer = DOM.elementByClass("img", "stickeroverlay", element);
                if (resizer) {
                    continue;
                }
                */

                var sticker = DOM.elementByClass("img", "stickerimage", element);

                /*
                var hover = document.createElement("img");
                hover.className = "stickeroverlay";
                hover.src = IMAGE_FOLDER + "/resizel.gif";
                hover.style.width = "11px";
                hover.style.height = "11px";
                element.appendChild(hover);
                */
                // hover.style.width = element.scrollWidth + "px";
                // hover.style.height = element.scrollHeight + "px";
                // element.onmouseover = function() { hover.style.backgroundColor = "red"; };
                // element.onmouseout = function() { hover.style.backgroundColor = "transparent"; };

                sticker.element = element;
                sticker.originalWidth = sticker.scrollWidth;
                sticker.originalHeight = sticker.scrollHeight;
                sticker.aspectRatio = (sticker.originalWidth == 0 || sticker.originalHeight == 0) ? 1 :
                        (1.0 * sticker.originalWidth / sticker.originalHeight);
                sticker.resizeWidth = sticker.originalWidth;
                sticker.resizeHeight = sticker.originalHeight;
                sticker.resizeX = 0;
                sticker.resizeY = 0;
                sticker.resizing = false;

                sticker.oncontextmenu = function(event) {
                    event = event || window.event;
                    if (event.stopPropagation) {
                        event.stopPropagation();
                    }
                    if (event.preventDefault) {
                        event.preventDefault();
                    }
                    event.cancelBubble = true;
                    return false;
                };
                sticker.onmousedown = function(event) {
                    if ($("delete").checked) { return Events.abort(event); }
                    this.resizing = true;
                    this.resizeX = event.clientX;
                    this.resizeY = event.clientY;
                    return Events.abort(event);
                };
                sticker.onmousemove = function(event) {
                    if (this.resizing) {
                        var dx = event.clientX - this.resizeX;
                        var dy = event.clientY - this.resizeY;
                        this.resizeX = event.clientX;
                        this.resizeY = event.clientY;
                        var newWidth = this.scrollWidth + dx;
                        var newHeight = this.scrollHeight + dy;
                        this.style.width = newWidth + "px";
                        this.style.height = newHeight + "px";

                        // fix aspect ratio if they shift-drag
                        if (event.shiftKey) {
                            if (Math.abs(dx) > Math.abs(dy)) {
                                var adjustedHeight = Math.round(this.scrollWidth / this.aspectRatio);
                                if (adjustedHeight) {
                                    this.style.height = Math.max(10, adjustedHeight) + "px";
                                }
                            } else {
                                var adjustedWidth = Math.round(this.aspectRatio * this.scrollHeight);
                                if (adjustedWidth) {
                                    this.style.width = Math.max(10, adjustedWidth) + "px";
                                }
                            }
                        }
                    }
                    return Events.abort(event);
                };
                sticker.onmouseup = function(event) {
                    this.resizing = false;
                    resizeOnServer(this.element.id, this.scrollWidth, this.scrollHeight);
                    return Events.abort(event);
                };
                sticker.onmouseover = function(event) {
                    // this.style.opacity = 0.5;
                    // this.element.style.backgroundColor = "#FFFF99";
                    if (event.button == 0) {
                        this.resizing = false;
                    }
                };
                sticker.onmouseout = function(event) {
                    // this.element.style.backgroundColor = "transparent";
                    // this.style.opacity = 1.0;
                }
            }
        }
    }
};

// private helper
Annotations.prototype.buildLineNumberMap = function() {
    var lineNumber = 1;
    for (var i = 0; i < this.codeText.length; i++) {
        var ch = this.codeText.charAt(i);
        this.lineNumberMap[i] = lineNumber;
        if (ch == "\n") {
            lineNumber++;
        }
    }
};

/** Returns true if it's possible to Undo right now. */
Annotations.prototype.canUndo = function() {
    return this.undoStack.length > 0;
};

/** Deletes all annotations. */
Annotations.prototype.clear = function() {
    this.takeUndoSnapshot();
    this.insertionList = Arrays.copy(this.htmlEntitiesInsertionList);
    this.clean();
};

Annotations.prototype.clean = function() {
    this.annotationList = [];
    this.rebuildHtml();
}

// private helper
// Given a selection index on the web page, converts it to an index in the original raw code.
// (The index returned is potentially smaller than the one passed in, because we're subtracting
// out any HTML entity encodings added to the file to put it on screen.)
Annotations.prototype.convertIndex = function(index) {
    var convertedIndex = index;
    for (var i = 0; i < this.wrapInsertionList.length; i++) {
        var start = this.wrapInsertionList[i].index;
        var length = this.wrapInsertionList[i].length;
        var end = start + length - 1;

        if (index >= end) {
            // this index is somewhere after the given insertion; so subtract its length
            convertedIndex -= length;
        } else if (index >= start && index <= end) {
            // this index is inside the given insertion, so it should start where it starts
            // return start;
            convertedIndex -= length;
        } else {
            // this index is before the given insertion; do nothing
        }
    }
    return convertedIndex;
};

Annotations.prototype.deselect = function() {
    if (this.selectedAnnotation) {
        var span = this.selectedAnnotation.getDomElement();
        span.style.borderTop = null;
        span.style.borderBottom = null;
        this.selectedAnnotation = null;
    }
};

Annotations.prototype.getAnnotationAtIndex = function(cleanIndex) {
    for (var i = 0; i < this.annotationList.length; i++) {
        if (this.annotationList[i].contains(cleanIndex)) {
            return this.annotationList[i];
        }
    }
    return null;
};

Annotations.prototype.getAnnotationById = function(id) {
    for (var i = 0; i < this.annotationList.length; i++) {
        if (this.annotationList[i].id == id) {
            return this.annotationList[i];
        }
    }
    return null;
};

Annotations.prototype.getCodeTextWithAnnotations = function() {
    return this.newCodeText;
};

// converts from an index in the original code file to one in the wrapped escaped code
Annotations.prototype.getDirtyStartIndex = function(cleanIndex) {
    var dirtyIndex = cleanIndex;
    for (var i = 0; i < this.insertionList.length; i++) {
        if ((this.insertionList[i].type == "htmlentity" && this.insertionList[i].index < cleanIndex) ||
            (this.insertionList[i].type != "htmlentity" && this.insertionList[i].index <= cleanIndex)) {
            dirtyIndex += this.insertionList[i].length;
        }
    }
    return dirtyIndex;
};

// converts from an index in the original code file to one in the wrapped escaped code
Annotations.prototype.getDirtyEndIndex = function(cleanIndex) {
    var dirtyIndex = cleanIndex;
    for (var i = 0; i < this.insertionList.length; i++) {
        if (this.insertionList[i].index < cleanIndex) {
            dirtyIndex += this.insertionList[i].length;
        }
    }

    return dirtyIndex;
};

Annotations.prototype.hasSelection = function() {
    return this.selectedAnnotation != null;
};

Annotations.prototype.isEmpty = function() {
    return this.annotationList.length == 0;
};

// returns what line a given "clean" index is on
Annotations.prototype.lineNumberFor = function(index) {
    return this.lineNumberMap[index];
};

Annotations.prototype.loadFromXml = function(ajax, filename) {
    var overallXml = null;
    try {
        overallXml = ajax.responseXML.getElementsByTagName("annotations")[0];
    } catch (e) {
        console.log(e);
    }

    if (!overallXml) {
        Page.dumpError("Error: No XML data or invalid XML data found in " + filename);
        return;
    }

    var records = overallXml.getElementsByTagName("record");
    for (var i = 0; i < records.length; i++) {
        if (!filename || records[i].getAttribute("filename") == filename) {
            var annotationsXml = records[i].getElementsByTagName("*");
            for (var j = 0; j < annotationsXml.length; j++) {
                var type  = annotationsXml[j].tagName;
                var id    = Number(annotationsXml[j].getAttribute("id"));
                var start = Number(annotationsXml[j].getAttribute("start"));
                var end   = Number(annotationsXml[j].getAttribute("end"));
                var text = undefined;
                var color = undefined;
                if ((annotationsXml[j].hasAttribute && annotationsXml[j].hasAttribute("color")) ||
                        (Browser.isIE() && annotationsXml[j].getAttribute("color"))) {
                    color = annotationsXml[j].getAttribute("color");
                }
                if (annotationsXml[j].firstChild && annotationsXml[j].firstChild.nodeValue) {
                    text = annotationsXml[j].firstChild.nodeValue.replace(/^\s+/g, "").replace(/\s$/g, "");
                }
                var width;
                var height;
                if ((annotationsXml[j].hasAttribute && annotationsXml[j].hasAttribute("width") && annotationsXml[j].hasAttribute("height")) ||
                        (Browser.isIE() && annotationsXml[j].getAttribute("width") && annotationsXml[j].getAttribute("height"))) {
                    width  = Number(annotationsXml[j].getAttribute("width"));
                    height = Number(annotationsXml[j].getAttribute("height"));
                }

                var annotation = new Annotation(type, id, start, end, text, color, width, height);
                this.add(annotation, true);
            }
        }
    }
    this.rebuildHtml();
};

Annotations.prototype.notify = function() {
    if (this.onchange) {
        this.onchange(this.newCodeText);
    }
};

Annotations.prototype.printDirtyIndexes = function() {
    var text = "";
    for (var i = 0; i < this.codeText.length; i++) {
        text += i + ":" + this.getDirtyStartIndex(i) + "-" + this.getDirtyEndIndex(i) + ":" + this.codeText.charAt(i).toPrintableChar() + " ";
    }
    Page.dump(text);
};

Annotations.prototype.printWrappedIndexes = function() {
    var text = "";
    for (var i = 0; i < this.wrappedCodeText.length; i++) {
        var c = this.convertIndex(i);  // should be smaller
        // if (i != c) {
            text += i + ":" + c + ":" + this.wrappedCodeText.charAt(i).toPrintableChar() + " ";
        // }
    }
    Page.dump(text);
};

Annotations.prototype.printInsertionList = function() {
    // print insertion list
    var text = "[";
    for (var i = 0; i < this.insertionList.length; i++) {
        text += this.insertionList[i].index + ":" + this.insertionList[i].length + ",";
    }
    Page.dump(text + "]");
};

Annotations.prototype.processHtmlEntities = function() {
    // build initial insertion list of HTML entities such as &lt;
    for (var i = 0, j = 0; i < this.wrappedCodeText.length &&
            j < this.escapedCodeText.length; i++, j++) {
        if (this.escapedCodeText.charAt(j) == "&") {
            var entityLength = 0;
            while (j < this.escapedCodeText.length && this.escapedCodeText.charAt(j) != ";") {
                j++;
                entityLength++;
            }

            // consider it to be a text insertion of length (entityLength - 1) because
            // for example, < to &lt; you go from 1 char to 4, so you add 3
            this.addToInsertionList({
                    index : this.convertIndex(i),
                    length : entityLength,
                    id : -1,
                    type : "htmlentity",
                    toString: insertionToString},
                true);
        }
    }
};

Annotations.prototype.processWrappedLines = function() {
    var i = 0;  // index into this.codeText
    var j = 0;  // index into this.wrappedCodeText

    while (i < this.codeText.length && j < this.wrappedCodeText.length) {
        if (this.codeText.charAt(i) == this.wrappedCodeText.charAt(j)) {
            i++;
            j++;
        } else {
            var start = i;
            var end = i;
            while (i < this.codeText.length &&
                    j < this.wrappedCodeText.length &&
                    this.codeText.charAt(i) != this.wrappedCodeText.charAt(j)) {
                // i++;
                j++;
                end++;
            }

            var length = end - start;
            // alert(start + " - " + end + " : " + length);
            this.addToInsertionList({
                    index : start,
                    "length" : length,
                    id : -1,
                    type : "wrap",
                    toString: insertionToString},
                true, true);
        }
    }
};

Annotations.prototype.rebuildHtml = function() {
    this.newCodeText = this.escapedCodeText;
    this.insertionList = Arrays.copy(this.htmlEntitiesInsertionList);

    for (var i = 0; i < this.annotationList.length; i++) {
        var annotation = this.annotationList[i];
        this.addToHtml(annotation);
    }

    // this.attachEventHandlers();
    // alert(this.insertionList.length + " " + this.insertionList);
    this.notify();
};

Annotations.prototype.removeAllInRange = function(start, end) {
    var changed = false;
    var indexesToRemove = [];
    for (var i = 0; i < this.annotationList.length; i++) {
        var a = this.annotationList[i];
        if (
            (a.start <= start && start <= a.end) ||
            (start <= a.start && a.end <= end) ||
            (a.start <= end && end <= a.end)
        ) {
            indexesToRemove.push(i);
            changed = true;
        }
    }

    if (changed) {
        this.takeUndoSnapshot();
        if (indexesToRemove.length > 1 &&
            !confirm("Deleting " + indexesToRemove.length + " annotations, are you sure?")) {
            deselect();
            return false;
        }

        for (var i = indexesToRemove.length - 1; i >= 0; i--) {
            this.removeAnnotationAtIndex(indexesToRemove[i], undefined, true);
        }
        this.rebuildHtml();
    }
    return changed;
};

Annotations.prototype.removeAnnotationAtCodeIndex = function(cleanIndex) {
    for (var i = 0; i < this.annotationList.length; i++) {
        var annotation = this.annotationList[i];
        if (annotation.contains(cleanIndex)) {
            return this.removeAnnotationAtIndex(i);
        }
    }
    return false;
};

// the canonical delete function, called by all others
Annotations.prototype.removeAnnotationAtIndex = function(index, skipRebuild, sync) {
    var annotation = this.annotationList[index];
    this.annotationList = Arrays.remove(this.annotationList, index);
    removeFromServer(annotation.id, sync);
    if (!skipRebuild) {
        this.rebuildHtml();
    }
    return true;
};

Annotations.prototype.removeAnnotationById = function(id) {
    for (var i = 0; i < this.annotationList.length; i++) {
        if (this.annotationList[i].id == id) {
            return this.removeAnnotationAtIndex(i);
        }
    }
    return false;
};

Annotations.prototype.removeSelection = function() {
    if (!this.hasSelection()) { return; }
    this.takeUndoSnapshot();
    var index = Arrays.indexOf(this.annotationList, this.selectedAnnotation);
    this.selectedAnnotation = null;
    return this.removeAnnotationAtIndex(index);
};

// private helper; saves state for later undoing
Annotations.prototype.takeUndoSnapshot = function() {
    if (this.undoStack.length >= Annotations.MAX_UNDO_SNAPSHOTS) {
        // discard oldest one
        this.undoStack.shift();
    }
    this.undoStack.push(deepCopy(this, undefined, 3));
};

/** Undoes the last operation.
 *  This is achieved by saving the entire Annotations object on each action
 *  and restoring it later.
 */
Annotations.prototype.undo = function() {
    if (!this.canUndo()) {
        return;
    }
    var oldState = this.undoStack.pop();

    // subtle bug: previous object has wrong undoStack state.
    var backupUndoStack = this.undoStack;
    Objects.shallowCopy(oldState, this);
    this.undoStack = backupUndoStack;

    this.rebuildHtml();

/*
    // remove the annotation from the lists
    var annotation = this.insertionStack.pop();
    this.insertionList = Arrays.remove(this.insertionList,
            Arrays.indexOf(this.insertionList, annotation));

    // many annotations have 2 parts in the insertion list; remove both
    if (this.insertionStack.length > 0 &&
        this.insertionStack[this.insertionStack.length - 1].id == annotation.id) {
        annotation = this.insertionStack.pop();
        insertionList = Arrays.remove(this.insertionList,
                Arrays.indexOf(this.insertionList, annotation));
    }

    // remove it from the text on the page
    this.annotationList.pop();
    this.rebuildHtml();
    return annotation.id;
*/
};


// Annotation class to store the data for one individual annotation on the page.
function Annotation(type, id, start, end, text, color, width, height) {
    this.type = type;
    this.id = id;
    this.start = start;
    this.end = end;
    this.text = text;
    this.color = color;
    this.width = width;
    this.height = height;
}

Annotation.prototype.contains = function(index) {
    return this.start <= index && index < this.end;
};

Annotation.prototype.getDomElement = function() {
    return $("" + this.id);
};

Annotation.prototype.toString = function() {
    return Page.getDumpText(this);
};


function annotationClick(event) {
    if ($("delete").checked) {
        // only listen to left mouse button clicks
        if (event.button != 0) {
            return;
        }

        annotations.removeAnnotationById(this.id);
    } else if (!this.className.match(/sticker/)) {
        if ($("annotate").checked) {
            // only listen to left mouse button clicks
            if (event.button != 0) {
                return;
            }

            var newText = prompt("New annotation text?", this.innerHTML.htmlDecode());
            if (newText) {
                annotations.takeUndoSnapshot();

                DOM.setText(this, newText.htmlEncode(true));
                var annotation = annotations.getAnnotationById(this.id);
                annotation.text = newText;
                modifyOnServer(this.id, newText);

                annotations.rebuildHtml();
                // annotations.notify();
            }
        } else if ($("select").checked) {
            // listen to left or right mouse button clicks
            var lineShift = (event.button == 0 && !event.shiftKey && !event.ctrlKey) ? 1 : -1;
            if (event.stopPropagation) {
                event.stopPropagation();
            }
            if (event.preventDefault) {
                event.preventDefault();
            }
            event.cancelBubble = true;

            // shift downward to avoid collisions between annotations
            annotations.takeUndoSnapshot();
            var annotation = annotations.getAnnotationById(this.id);

            // move it down by one line
            var start = annotation.start;
            var originalLineNumber = annotations.lineNumberFor(start);
            var lineNumber = originalLineNumber;
            while (lineNumber == originalLineNumber) {
                start += lineShift;
                lineNumber = annotations.lineNumberFor(start);
            }
            start += lineShift;
            lineNumber = annotations.lineNumberFor(start);

            // to avoid landing on a \n character
            //if (lineShift < 0 && start > 0) {
            //    start--;
            //}

            if (typeof(lineNumber) !== "undefined") {
                annotation.start = start;
                modifyOnServer(this.id, annotation.text, start);
                annotations.rebuildHtml();
            }
            return false;
        }
    }
}

function doEnabling() {
    if (window && window.getCodeSelection && window.annotations) {
        var selection = window.getCodeSelection();
        if (selection) {
            annotations.deselect();
        }
    }
    doButtonEnabling();
}

function doButtonEnabling() {
    $("undo").disabled = !annotations || !annotations.canUndo();
    $("clearall").disabled = annotations && annotations.isEmpty();
    $("blockselect").disabled = !$("highlight").checked && !$("annotate").checked && !$("strikeout").checked;
    // $("delete").disabled = !annotations.hasSelection();

    var colors = $("highlightcolors").getElementsByTagName("input");
    for (var i = 0; i < colors.length; i++) {
        colors[i].disabled = !$("highlight").checked && !$("annotate").checked;
    }
}

function insertionToString() {
    return "Insertion{index=" + this.index + ", length=" + this.length + ", id=" + this.id + ", type=" + this.type + "}";
}

function removeFromServer(id, sync) {
    // send the removal to the server
    if (SHOULD_SEND_TO_SERVER) {
        var query = getQueryStringWithFilename();
        query["action"] = "remove";
        query["id"] = id;
        sendAnnotationMessageToServer(query, undefined, sync);
    }

    doEnabling();
}

/** Informs the server about the resizing of a sticker. */
function resizeOnServer(id, width, height) {
    if (SHOULD_SEND_TO_SERVER) {
        var query = getQueryStringWithFilename();
        query["action"] = "resize";
        query["width"] = width;
        query["height"] = height;
        query["id"] = id;
        Page.loadingShow("Saving...");
        AjaxTools.post(Annotations.ANNOTATION_PAGE, Page.buildQueryString(query), Page.loadingHide);
    }
}

// wrapper to send any message to server about annotations
function sendAnnotationMessageToServer(query, fn, sync) {
    Page.loadingShow("Submitting...");
    var successFunc = function() {
        Page.loadingHide(undefined, false);
        if (fn) {
            fn();
        }
    };
    var errorFunc = function() {
        Page.loadingShow("ERROR: please refresh the page");
        alert("An error occurred while attempting to post the annotation. Refresh the page to ensure you are logged in and try again.");
    };

    AjaxTools.post(Annotations.ANNOTATION_PAGE, Page.buildQueryString(query), successFunc, errorFunc, sync);
}
            </script>

        
            <script type="text/javascript">
                <!-- jsfile = common.js -->
                // This file contains shared JS functions for GradeIt.

// This file needs to know what path to source static resources from. BASE_PATH needs to be defined...
// At the moment, this is just happening via a little <script> in <head> -- don't think it needs
// to get any more complicated than that for a while.
//
// Longer term TODO -- there's no reason that we couldn't host the JS for GradeIt in a single
// shared location. Then, all the instances could hold absolute links to the JS instead of
// everyone maintaining their own copy.
var IMAGE_FOLDER = GradeIt.BASE_PATH + "/img";

/** A shortcut for document.getElementById, as used in Prototype and other JS frameworks. */
if (typeof($) !== "function") {
	var $ = function(id) {
		var element = id;
		if (typeof(id) == "string") {
			element = document.getElementById(id);
		} else if (typeof(id) == "number") {
			element = document.getElementById("" + id);
		}

		// allow for the possibility of Prototype
		if (typeof(Element) !== "undefined" && Element.extend) {
			element = Element.extend(element);
		}

		return element;
	};
}

/** A shortcut for document.querySelectorAll, as used in Prototype and other JS frameworks. */
if (typeof($$) !== "function") {
	var $$ = function(s) {
		return document.querySelectorAll(s);
	};
}

// array-like enumeration
if (!Array.forEach) { // mozilla already supports this
	Array.forEach = function(array, block, context) {
		for (var i = 0; i < array.length; i++) {
			block.call(context, array[i], i, array);
		}
	};
}

/** AjaxTools class to store functions related to doing Ajaxy things on the page. */
if (typeof(AjaxTools) === "undefined") {
	function AjaxTools() {}
	AjaxTools.currentElement = null;
}

/**
 * Fetches data using Ajax and calls the given function when it arrives.
 * Third parameter specifies an object on which to call the function.
 *
 * @param {String} url        URL whose data should be fetched
 * @param {function} fn       function to call when data arrives successfully
 * @param {Object} obj        object (if any) on which to call fn
 * @param {function} errorFn  function to call if data fails to arrive successfully
 * @param {boolean} sync      synchronized request?
 * @param {String} method     "GET" or "POST"
 * @param {String} postData   data to attach to the POST request, if any
 */
AjaxTools.fetch = function(url, fn, obj, errorFn, sync, method, postData) {
	// make it IE compatible (students don't have to do this)
	var ajax;
	if (window.XMLHttpRequest) {
		ajax = new XMLHttpRequest();
	} else if (window.ActiveXObject) {
		ajax = new ActiveXObject("Microsoft.XMLHTTP");
	}

	sync = (sync) ? true : false;
	if (!method) {
		method = "GET";
	}

	// convert relative URLs to absolute, to avoid a Firebug bug with relative URLs
	if (!url.match(/^\//) && !url.match(/:\/\//)) {
		var path = location.pathname;
		var last = path.lastIndexOf("/");
		if (last >= 0) {
			path = path.substring(0, last + 1);
		}

		url = location.protocol + "//" +
				(location.hostname ? location.hostname : location.host) +
				(location.port ? ":" + location.port : "") +
				path +
				url;
	}

	// call this when Ajax is done
	var responseFunction = function(ajax) {
		var isLoginRedirect = ajax.responseURL && ajax.responseURL.match(/auth\/login/);

		if ((ajax.status == 200 || (ajax.status == 0 && ajax.responseText)) &&
			!Page.hasError(ajax.responseText) &&
			!isLoginRedirect
		) {
			// request received successfully
			if (fn) {
				if (obj) {
					fn.apply(obj, [ajax]);
				} else {
					fn(ajax);
				}
			}
		} else {
			var message = "An error occurred during the AJAX call";
			if (isLoginRedirect) {
				message += ", you are no longer logged in";
			}
			ajax.gradeitErrorMessage = message;
			// something went wrong
			if (errorFn) {
				errorFn(ajax);
			} else  {
				AjaxTools.standardErrorHandler(ajax, url);
			}
		}
	};

	if (!sync) {
		// the code that should be run when the request completes
		ajax.onerror = function() {
			responseFunction(ajax);
		};
		ajax.onload = function() {
			// if (ajax.readyState != 4) { return; }
			responseFunction(ajax);
		};
	}

	// *** TODO: Does it even ever call fn if it's set to sync mode?
	if (method == "GET") {
		ajax.open("GET", url, !sync);
		ajax.send(null);
	} else {  // post
		ajax.open("POST", url, !sync);
		ajax.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");

		// example:
		// ajax.send("id=1&user="+txtUser.value+"&password="+txtPassword.value);

		ajax.send(postData);   // key=value pairs?
	}

	if (sync) {
		// need to call the callback now
		responseFunction(ajax);
	}

	return ajax;
}

/** Fetches the given URL and puts its text into the given div. */
AjaxTools.fill = function(div, url) {
	this.fetch(url, function(ajax) {
		div.innerHTML = ajax.responseText;
	});
};

/** Temporary; needs to be refactored to merge with fetch. */
AjaxTools.post = function(url, data, fn, errorFn, sync) {
	return AjaxTools.fetch(url, fn, undefined, errorFn, sync, "POST", data);
};

/** Reloads the page when an Ajax request is complete. */
AjaxTools.reloadPage = function(ajax, nocache) {
	if (!GradeIt.debugMode() || confirm("DEBUG MODE: Really reload page?")) {
		if (nocache) {
			// add useless query parameter so it won't be cached
			var url = Page.toUncacheableURL();
			window.location = url;
		} else {
			window.location.reload();
		}
	}
};

/** A standard default function for handling Ajax errors.
 *  Used when no value is passed for errorFn in fetch method.
 */
AjaxTools.standardErrorHandler = function(ajax, url) {
	if (typeof(AjaxTools.currentElement) !== "undefined" &&
			AjaxTools.currentElement &&
			AjaxTools.currentElement.inProgress) {
		AjaxTools.currentElement.inProgress = false;
	}

	var message = "An error occurred during the Ajax request";
	if (ajax.gradeitErrorMessage) {
		message = ajax.gradeitErrorMessage;
	}

	if (url) {
		message += ":\n\n Requested Url:" + url;
	}
	message +=
		"\n\nServer status:\n" + ajax.status + " " + ajax.statusText +
		"\n\n" + ajax.responseText.trim();

	Page.dumpError(message);
	alert(message);
	Page.loadingHide("Failed.");
};

/** Submits the given form as a background Ajax task. */
AjaxTools.submitForm = function(form, message, fn, errorFn, sync) {
	AjaxTools.currentElement = form;

	// form can be the actual form DOM object, or the string of its id
	if (typeof(form) == "string") {
		form = $(form);
	}
	if (!message) {
		message = "Submitting...";
	}

	var queryParams = Forms.getQueryParams(form);
	Page.loadingShow(message);

	var action = form.getAttribute("action");

	var errorFunction = function(ajax) {
		Page.loadingHide("Failed.");
		if (errorFn) {
			errorFn(ajax);
		} else {
			AjaxTools.standardErrorHandler(ajax, action);
		}
	};

	var successFunction = function(ajax) {
		if (Page.hasError(ajax.responseText)) {
			// page came back but had errors
			errorFunction(ajax);
		} else {
			Page.loadingHide();
			if (fn) {
				fn(ajax);
			}
		}
	};

	AjaxTools.post(action, Page.buildQueryString(queryParams), successFunction, errorFunction, sync);
};


/** Arrays class to store functions related to arrays. */
if (typeof(Arrays) === "undefined") {
	function Arrays() {}
}

/** Returns true if the given element is contained in the given array, or false if not found.
Only works for arrays whose indexes are integers (not for hashes). */
Arrays.contains = function(array, element) {
	return Arrays.indexOf(array, element) >= 0;
};

/** Returns a duplicate of the given array. */
Arrays.copy = function(array) {
	var newArray = [];
	// for (var key in array) {
	//     newArray[key] = array[key];
	// }
	for (var i = 0; i < array.length; i++) {
		newArray[i] = array[i];
	}
	return newArray;
};

/** Returns first index of the given element in the given array (-1 if not found).
	Array object has this function in Firefox, but IE6 blows so I have to rewrite it. */
Arrays.indexOf = function(array, element) {
	for (var i = 0; i < array.length; i++) {
		if (array[i] == element) {
			return i;
		}
	}
	return -1;
};

/** Removes element at given index from given array and slides others over. */
Arrays.remove = function(array, index) {
	if (typeof(index) != "number") {
		return Arrays.removeElement(array, index);
	}
	var result = array.slice(0, index).concat(array.slice(index + 1));
	return result;
};

/** Removes given element value from given array and slides others over. */
Arrays.removeElement = function(array, element) {
	return Arrays.remove(array, Arrays.indexOf(array, element));
};

/** Rearranges the contents of the given array into random order. */
Arrays.shuffle = function(array) {
	for (var i = 0; i < array.length - 1; i++) {
		var j = Math.floor(Math.random() * (array.length - i)) + i;
		var temp = array[i];
		array[i] = array[j];
		array[j] = temp;
	}
};




/** Browser class stores things related to the web browser viewing the page. */
if (typeof(Browser) === "undefined") {
	function Browser() {}
}

/** Returns true if the current web browser is MS IE 6 (aka, fracking piece of she-it). */
Browser.isIE6 = function() {
	return Browser.isIE() && navigator.appVersion.match(/MSIE 6/);
};

/** Returns true if the current web browser is MS IE 7 (aka, not QUITE as much of a fracking piece of she-it). */
Browser.isIE7 = function() {
	return Browser.isIE() && navigator.appVersion.match(/MSIE 7/);
};

/** Returns true if the current web browser is MS IE 8 (aka, a little bit less of a fracking piece of fracking, but still a fracking piece of she-it). */
Browser.isIE8 = function() {
	return Browser.isIE() && navigator.appVersion.match(/MSIE 8/);
};

/** Returns true if the current web browser is any version of IE. */
Browser.isIE = function() {
	return navigator.appName.match(/Internet Explorer/);
};

/** Returns true if the current web browser is any version of Apple Safari. */
Browser.isSafari = function() {
	return navigator.userAgent.indexOf('AppleWebKit') >= 0;
}


/** Cookie class stores things related to cookies. */
if (typeof(Cookies) === "undefined") {
	function Cookies() {}
}

/**
 * Cookies utility class by Marty Stepp
 * Relies on Prototype framework being loaded on the current page.
 */


/** Cookie class stores things related to cookies. */
function Cookies() {}
Cookies.SEMICOLON_PLACEHOLDER = "_&SEMI_";
Cookies.COMMA_PLACEHOLDER = "_&COMMA_";

/** Strips illegal cookie-name characters from the given cookie name and returns it. */
Cookies.encodeName = function(name) {
	if (name) {
		name = name.replace(/[^a-zA-Z0-9_]+/g, "");  // strip illegal chars
	}
	return name;
};

/** Returns true if a cookie exists with the given name. */
Cookies.exists = function(name) {
	name = Cookies.encodeName(name);
	var value = Cookies.get(name);
	return value !== null;
};

/** Returns the value of the cookie with the given name (null if not found). */
Cookies.get = function(name) {
	name = Cookies.encodeName(name);

	var nameEQ = name + "=";
	var ca = document.cookie.split(/[ ]*;[ ]*/);
	for (var i = 0; i < ca.length; i++) {
		var c = ca[i];
		if (c.indexOf(nameEQ) == 0) {
			c = c.substring(nameEQ.length);
			c = c.replace(new RegExp(Cookies.SEMICOLON_PLACEHOLDER, "g"), ";");    // undo encoded semicolon placeholder
			c = c.replace(new RegExp(Cookies.COMMA_PLACEHOLDER, "g"), ",");         // undo encoded comma placeholder
			return c;
		}
	}
	return null;
};

/** Turns the given checkbox into one that will remember its checked-ness,
 *  using a client-side cookie with the given name.
 */
Cookies.makeCheckboxStateful = function(element, cookieName, expiration) {
	element = $(element);
	if (!cookieName) {
		cookieName = element.id;
	}
	if (!cookieName) {
		return;
	}

	cookieName = Cookies.encodeName(cookieName);

	element.cookieName = cookieName;
	if (Cookies.exists(cookieName) && !element.disabled) {
		var shouldBeChecked = (Cookies.get(cookieName) == "true");
		if (element.checked != shouldBeChecked) {
			if (element.onclick) {
				element.onclick();
			}
			if (element.onchange) {
				element.onchange();
			}
			element.checked = shouldBeChecked;
		}
	}
	Events.addEventListener(element, "change", function(event) {
		Cookies.statefulCheckboxChange(element, cookieName, expiration);
	});
};

/** Turns the given radio into one that will remember its checked-ness,
 *  using a client-side cookie with the given name.
 *  Will also uncheck other radio buttons in the same name group.
 */
Cookies.makeRadioButtonStateful = function(element, cookieName, expiration) {
	element = $(element);
	if (!element) {
		return;
	}
	if (!cookieName) {
		cookieName = element.id;
	}
	if (!cookieName) {
		return;
	}

	cookieName = Cookies.encodeName(cookieName);

	element.cookieName = cookieName;
	if (Cookies.exists(cookieName)) {
		var shouldBeChecked = (Cookies.get(cookieName) == "true");
		if (element.checked != shouldBeChecked) {
			if (!element.disabled) {
				if (element.onclick) {
					element.onclick();
				}
				if (element.onchange) {
					element.onchange();
				}
			}
			element.checked = shouldBeChecked;
		}
	}

	if (!element.disabled) {
		Events.addEventListener(element, "change", function(event) {
			Cookies.statefulRadioButtonChange(element, cookieName, expiration);
		});
	}
};

/** Turns the given select box into one that will remember its selected value,
 *  using a client-side cookie with the given name.
 */
Cookies.makeSelectStateful = function(element, cookieName, expiration) {
	element = $(element);
	if (!element) {
		return;
	}

	if (!cookieName) {
		cookieName = element.id;
	}
	if (!cookieName) {
		return;
	}

	cookieName = Cookies.encodeName(cookieName);
	element.cookieName = cookieName;

	// If the <select> had a selected option in it, we must have done that server side -- respect it.
	if (Cookies.exists(cookieName) && !(element.querySelectorAll("option[selected]").length)) {
		element.value = Cookies.get(cookieName);
	}
	Events.addEventListener(element, "change", function(event) {
		Cookies.statefulSelectChange(element, cookieName, expiration);
	});
};

/** Turns the given input text box into one that will remember its selected value,
 *  using a client-side cookie with the given name.
 *  Basically identical code to makeSelectStateful...
 */
Cookies.makeTextBoxStateful = function(element, cookieName, expiration) {
	element = $(element);
	if (!element) {
		return;
	}
	if (!cookieName) {
		cookieName = element.id;
	}
	if (!cookieName) {
		return;
	}

	cookieName = Cookies.encodeName(cookieName);

	element.cookieName = cookieName;
	if (Cookies.exists(cookieName)) {
		element.value = Cookies.get(cookieName);
		if (element.onchange) {
			element.onchange();
		}
	}
	Events.addEventListener(element, "change", function(event) {
		Cookies.statefulSelectChange(element, cookieName, expiration);
	});
};

/** Removes the cookie with the given name. */
Cookies.remove = function(name) {
	// document.cookie = Cookies.encodeName(name) + "=; expires=Thu, 01-Jan-70 00:00:01 GMT;";
	document.cookie = Cookies.encodeName(name) + "=; expires=Thu, 01-Jan-70 00:00:01 GMT;";
	Cookies.set(name, "", -1);
};

/** Sets the cookie with the given name to have the given value.
 *  Taken from http://www.quirksmode.org/js/cookies.html
 */
Cookies.set = function(name, value, days) {
	name = Cookies.encodeName(name);
	if (value && value.replace) {
		value = value.replace(/;/g, Cookies.SEMICOLON_PLACEHOLDER);   // semicolon is the cookie delimiter; must escape
		value = value.replace(/,/g, Cookies.COMMA_PLACEHOLDER);       // comma is also a cookie delimiter; must escape
	}


	if (days == 0) {
		// if you set it to remain for 0 days, it will stay only for the current browser session
		var expires = "";
	} else {
		// set the cookie to expire the given number of days in the future
		var date = new Date();
		date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
		var expires = "; expires=" + date.toGMTString();
	}
	document.cookie = name + "=" + value + expires + "; path=/";
};

// This function is called when a "stateful" checkbox's checked state
// changes, and stores that state in a cookie to be restored later.
Cookies.statefulCheckboxChange = function(element, cookieName, expiration) {
	if (!expiration) {
		expiration = 30;   // default # days
	}
	element = $(element);
	if (!cookieName) {
		cookieName = element.id;
	}
	if (!cookieName) {
		return;
	}
	cookieName = cookieName.replace(/[^a-zA-Z0-9_]+/g, "");  // strip illegal chars
	Cookies.set(cookieName, element.checked ? "true" : "false", expiration);
};

// This function is called when a "stateful" radio button's checked state
// changes, and stores that state in a cookie to be restored later.
Cookies.statefulRadioButtonChange = function(element, cookieName, expiration) {
	if (!expiration) {
		expiration = 30;   // default # days
	}
	element = $(element);
	if (!cookieName) {
		cookieName = element.id;
	}
	if (!cookieName) {
		return;
	}
	cookieName = Cookies.encodeName(cookieName);

	var radios = document.getElementsByName(element.name);
	for (var i = 0; i < radios.length; i++) {
		if (radios[i].cookieName) {
			Cookies.set(radios[i].cookieName, "false", expiration);
		}
	}
	Cookies.set(cookieName, element.checked ? "true" : "false", expiration);
};

// This function is called when a "stateful" select box's selected element
// changes, and stores that value in a cookie to be restored later.
Cookies.statefulSelectChange = function(element, cookieName, expiration) {
	if (!expiration) {
		expiration = 30;   // default # days
	}
	element = $(element);
	if (!cookieName) {
		cookieName = element.id;
	}
	if (!cookieName) {
		return;
	}
	cookieName = Cookies.encodeName(cookieName);
	Cookies.set(cookieName, element.value, expiration);
};



/** DOM class stores things related to manipulating the page through the DOM. */
if (typeof(DOM) === "undefined") {
	function DOM() {}
}

/** Applies the given CSS class to the given element. */
DOM.addClass = function(element, className) {
	if (!DOM.hasClass(element, className)) {
		element.className += " " + className;
	}
};

/** Adds the given text to the end of the given element's inner text. */
DOM.appendText = function(element, text) {
    //	element.textContent += text;
	element.innerText += text;
};

/** Returns the first found direct child of the given root node that has the given CSS class.
 *  root and tagName optional (defaults to entire page and any tag)
 *  Returns null if no such child found.
 */
DOM.child = function(tagName, className, root) {
	if (!root) {
		root = document.body;
	}
	var kids = root.childNodes;
	for (var i = 0; i < kids.length; i++) {
		if (DOM.hasClass(kids[i], className) &&
			DOM.isTagName(kids[i], tagName)) {
			return kids[i];
		}
	}
	return null;
};

/** Returns all direct children of the given root node that have the given CSS class.
 *  root and tagName optional (defaults to entire page and any tag)
 */
DOM.children = function(tagName, className, root) {
	if (!root) {
		root = document.body;
	}
	var kids = root.childNodes;
	var result = [];
	for (var i = 0; i < kids.length; i++) {
		if (DOM.hasClass(kids[i], className) &&
			DOM.isTagName(kids[i], tagName)) {
			result.push(kids[i]);
		}
	}
	return result;
}

/** Returns all CSS classes of the given DOM element as an array. */
DOM.classes = function(element) {
	return element.className.split(/\s+/);
};

/** Returns all descendents of the given root node with the given HTML tag
 *  and CSS class. root and tagName optional (defaults to entire page and any tag)
 */
DOM.descendent = function(tagName, className, root) {
	if (!root) {
		root = document.body;
	}
	if (!tagName) {
		tagName = "*";
	}
	var kids = root.getElementsByTagName(tagName);
	for (var i = 0; i < kids.length; i++) {
		if (DOM.hasClass(kids[i], className) &&
			DOM.isTagName(kids[i], tagName)) {
			return kids[i];
		}
	}
	return null;
}

/** Returns the first descendent of the given root node with the given HTML tag
 *  and CSS class. root and tagName optional (defaults to entire page and any tag)
 */
DOM.descendents = function(tagName, className, root) {
	if (!root) {
		root = document.body;
	}
	if (!tagName) {
		tagName = "*";
	}
	var kids = root.getElementsByTagName(tagName);
	if (!className) {
		return kids;
	}
	var result = [];
	for (var i = 0; i < kids.length; i++) {
		if (DOM.hasClass(kids[i], className) &&
			DOM.isTagName(kids[i], tagName)) {
			result.push(kids[i]);
		}
	}
	return result;
}

/** Returns the first found element with the given HTML tag and CSS class
 *  within the given DOM root node on the page.  null if not found.
 */
DOM.elementByClass = function(tagName, className, root) {
	var elements;
	if (!root) {
		root = document;
	}
	elements = root.getElementsByTagName(tagName);

	for (var i = 0; i < elements.length; i++) {
		if (DOM.hasClass(elements[i], className)) {
			return elements[i];
		}
	}
	return null;
};

/** Returns an array of all found elements with the given HTML tag and CSS class
 *  within the given DOM root node on the page.
 */
DOM.elementsByClass = function(tagName, className, root) {
	var elements;
	if (!root) {
		root = document;
	}
	elements = root.getElementsByTagName(tagName);

	var result = [];
	for (var i = 0; i < elements.length; i++) {
		if (DOM.hasClass(elements[i], className)) {
			result.push(elements[i]);
		}
	}
	return result;
};

/** Returns the value stored inside the given form element, such as a textarea or input box. */
DOM.elementValue = function(element) {
	var value;
	if (element.value) {
		value = element.value;
	} else if (element.innerHTML) {
		value = element.innerHTML;
	}
	return value;
};

/** Returns the element that contains the given 'root' with given tag ("*" for any tag)
 *  whose CSS class contains the given class name.
 *  Returns null if not found.
 */
DOM.enclosingElement = function(tagName, className, root) {
	if (root) {
		do {
			root = root.parentNode;
		} while (root && (!DOM.isTagName(root, tagName) || !DOM.hasClass(root, className)));
	}
	return root;
};

/** Applies a cool animated fade effect to make the given element disappear. */
DOM.fade = function(element, delay, initialDelay) {
	if (!delay) {
		delay = 200;
	}
	if (!initialDelay || initialDelay < 0) {
		initialDelay = 0;
	}
	element.style.opacity = 1.0;

	// show message for 5 sec then disappear
	var timer = null;
	var fadeFunc = function() {
		// loading.style.visibility = "hidden";
		if (!DOM.fadeTick(element)) {
			clearInterval(timer);
		}
	};

	if (initialDelay) {
		setTimeout(function() {
			timer = setInterval(fadeFunc, delay);
		}, initialDelay);
	} else {
		timer = setInterval(fadeFunc, delay);
	}
};

/** Callback that does one frame of animation of the cool animated fade effect. */
DOM.fadeTick = function(element) {
	var opacityIncr = 0.05;
	if (typeof(element.style.opacity) === "undefined") {
		element.style.opacity = 1.0 - opacityIncr;
		return true;
	} else {
		if (element.style.opacity > 0.0) {
			// decrease opacity (fade) a bit
			var newOpacity = Math.max(0.0, element.style.opacity - opacityIncr);
			element.style.opacity = newOpacity;
		}

		if (element.style.opacity > 0.0) {
			return true;
		} else {
			// done fading?
			// element.style.visibility = "hidden";
			element.style.display = "none";
			element.style.opacity = 0.0;
			return false;
		}
	}
};

/** stolen from Prototype; gets current style of an element's given CSS property */
DOM.getStyle = function(element, style) {
	style = style == 'float' ? 'cssFloat' : style;
	var value = element.style[style];
	if (!value) {
		if (document.defaultView && document.defaultView.getComputedStyle) {
			var css = document.defaultView.getComputedStyle(element, null);
			value = css ? css[style] : null;
		}

		if (!value && element.currentStyle) {
			value = element.currentStyle;
		}
	}
	if (style == 'opacity') {
		return value ? parseFloat(value) : 1.0;
	}
	return value == 'auto' ? null : value;
};

/** Gets and returns the text content inside the given element.
 *  I need this because IE uses .innerText and FF uses .textContent ... bleh.
 */
DOM.getText = function(element) {
	if (!element) {
		return null;
	} else if (element.textContent !== undefined) {
		return element.textContent;
	} else if (element.innerText !== undefined) {
		return element.innerText;
	} else if (element.value !== undefined) {
		return element.value;
	} else {
		return null;
	}
};

/** Returns true if the given DOM element's CSS class name contains the given class name.
 *  If the className is empty or is "*", returns true.
 */
DOM.hasClass = function(element, className) {
	if (!element) {
		return false;
	} else if (!className || className == "*") {
		return true;
	} else if (!element.className) {
		return false;
	}

	var classes = DOM.classes(element);
	for (var i = 0; i < classes.length; i++) {
		if (classes[i] == className) {
			return true;
		}
	}
	return false;
};

/** Returns true if the given element uses the given HTML tag, case-insensitive.
 *  If the tagName is empty or is "*", returns true.
 */
DOM.isTagName = function(element, tagName) {
	if (!element) {
		return false;
	} else if (!tagName || tagName == "*") {
		return true;
	}

	var nodeName = element.nodeName.toLowerCase();
	if (tagName) { tagName = tagName.toLowerCase(); }
	return nodeName == tagName;
};

/** Returns true if the given element is currently being displayed. */
DOM.isVisible = function(element, type, assumeEmptyMeansInvisible) {
	if (!element) {
		return false;
	}
	if (!type) {
		type = (assumeEmptyMeansInvisible) ? "block" : "";
	}

	// var opacity0 = element.style.opacity === 0 || element.style.opacity === "0" || element.style.opacity === "0.0";
	var display = DOM.getStyle(element, "display");
	var visibility = DOM.getStyle(element, "visibility");
	var opacity = DOM.getStyle(element, "opacity");

	var noneSet = !display && !visibility && !opacity;

	var hiddenByDisplay    = (assumeEmptyMeansInvisible && noneSet) || display == "none";
	var hiddenByVisibility = (assumeEmptyMeansInvisible && noneSet) || visibility == "hidden";
	var hiddenByOpacity    = (assumeEmptyMeansInvisible && noneSet) || (opacity === 0 || opacity === 0 || opacity === 0.0 || opacity === "0" || opacity === "0.0");

	return !hiddenByDisplay && !hiddenByVisibility && !hiddenByOpacity;
};

/** Returns the next sibling of the given root that has the given HTML tag and CSS class. */
DOM.nextSibling = function(tagName, className, root) {
	var sibling = root;
	do {
		sibling = sibling.nextSibling;
	} while (sibling && (!DOM.isTagName(sibling, tagName) || !DOM.hasClass(sibling, className)));

	return sibling;
};

/** Creates and returns a DOM div node whose inner HTML is the given text. */
DOM.nodeFromHtml = function(text) {
	var node = document.createElement("div");
	node.innerHTML = text;
	return node;
};

/** Returns the previous sibling of the given root that has the given HTML tag and CSS class. */
DOM.previousSibling = function(tagName, className, root) {
	var sibling = root;
	do {
		sibling = sibling.previousSibling;
	} while (sibling && !DOM.isTagName(sibling, tagName) || !DOM.hasClass(sibling, className));

	return sibling;
}

/** Kills all of the given DOM element's children. */
DOM.removeAllChildren = function(element) {
	while (element.firstChild) {
		element.removeChild(element.firstChild);
	}
};

/** Removes 'this' node from the page. */
DOM.removeMyself = function(element) {
	if (!element) {
		element = this;
	}
	if (element.parentNode) {
		element.parentNode.removeChild(element);
	}
};

/** Removes the given CSS class from the given element. */
DOM.removeClass = function(element, className) {
	if (DOM.hasClass(element, className)) {
		var classes = DOM.classes(element);
		classes = Arrays.removeElement(classes, className);
		DOM.setClasses(element, classes);
	}
};

/** Sets the CSS className of the given DOM element to be the contents
 *  of the array, joined by spaces.
 */
DOM.setClasses = function(element, classes) {
	element.className = classes.join(" ");
};

/** Sets the given DOM element's inner text content to be the given text.
 *  A wrapper because IE uses .innerText and FF uses .textContent.
 */
DOM.setText = function(element, text) {
	element.textContent = text;
	element.innerText = text;
};

/** Returns the first sibling of the given root node with the given tag and/or class. */
DOM.sibling = function(tagName, className, root) {
	var kids = null;
	if (root && root.parentNode) {
		kids = root.parentNode.childNodes;
	} else {
		throw "oh shit!";
		kids = document.body.childNodes;
	}
	for (var i = 0; i < kids.length; i++) {
		if (DOM.hasClass(kids[i], className) && DOM.isTagName(kids[i], tagName)) {
			return kids[i];
		}
	}
	return null;
};

DOM.siblings = function(tagName, className, root) {
	var kids = root.parentNode.childNodes;
	var result = [];
	for (var i = 0; i < kids.length; i++) {
		if (kids[i] != root && DOM.hasClass(kids[i], className) && DOM.isTagName(kids[i], tagName)) {
			result.push(kids[i]);
		}
	}
	return result;
};

/** Toggles the given element between displaying and not displaying.
 *  type is "block", "inline", etc.  assumed to be "block"
 */
DOM.toggleDisplay = function(element, type, assumeEmptyMeansInvisible, force) {
	if (!element) {
		return;
	}

	if (!type) {
		type = (assumeEmptyMeansInvisible) ? "block" : "";
	}

	if (force || !DOM.isVisible(element, type, assumeEmptyMeansInvisible)) {
		element.style.display = type;
	} else {
		element.style.display = "none";
	}
};

DOM.toggleClass = function(elements, className) {
	if (!elements || !className) {
		return;
	}

	// If they just gave us one element...
	if (!Array.isArray(elements)) {
		elements = [ elements ];
	}

	Array.forEach(elements, function(element) {
		if (DOM.hasClass(element,className)) {
			DOM.removeClass(element, className);
		} else {
			DOM.addClass(element, className);
		}
	});


};

/** Events class stores functions related to event-handling. */
if (typeof(Events) === "undefined") {
	function Events() {}
}

/** Stops an event from bubbling out (e.g. a form submission). */
Events.stop = Events.abort = function(event) {
	if (event) {
		if (event.preventDefault) {
			event.preventDefault();
		}
		if (event.stopPropagation) {
			event.stopPropagation();
		}
		event.cancelBubble = true;
	}
	return false;
};

/** stops an Enter keypress on a text field from submitting a form. */
Events.abortFormSubmit = function(event) {
	event = Events.standardize(event);
	key = event.keyCode || event.which;
	if (key == 13) {  // user pressed Enter
		// don't let form submit
		return Events.abort(event);
	}
};

/** A cross-browser event handler attaching function. */
Events.addEventListener = function(element, event, fn) {
	if (!element) {
		return;
	}
	if (element.addEventListener) {
		element.addEventListener(event, fn, false);
	} else if (element.attachEvent) {
		// hey IE6, fuck you.
		// alert("uh oh");
		// element.attachEvent("on" + event, fn);
		element["on" + event] = fn;
	}
};

/** Calls the given function when the given link is clicked.
 *  Also sets the href of the link so that the cursor becomes a hand when hovering on it.
 */
Events.addLinkListener = function(links, fn, setHref) {
	if (typeof(links) == "string") {
		links = [ $(links) ];
	} else if (typeof(links) != "array") {
		links = [ links ];
	}

	Array.forEach(links, function( link ) {
		Events.addEventListener(link, "click", fn);
		if (link && !link.href && setHref !== false) {
			link.href = "#";   // so that the cursor will turn into a lil hand
		}
	})
};

Events.addOnClickListener = function( elements, fn ) {
	Array.forEach(elements, function(elm) {
		elm.onclick = fn;
	});
}

/** Attaches a window onload handler. */
Events.addOnLoad = function(fn) {
	if (document.observe) {
		// Prototype
		document.observe("dom:loaded", fn);
	}
	else {
		Events.addEventListener(window, "load", fn);
		// Page.dump("slow onLoad!!!");
	}
};

Events.simulate = function(element, eventName) {
	var eventMatchers = {
		'HTMLEvents': /^(?:load|unload|abort|error|select|change|submit|reset|focus|blur|resize|scroll)$/,
		'MouseEvents': /^(?:click|mouse(?:down|up|over|move|out))$/
	}
	var defaultOptions = {
		pointerX: 0,
		pointerY: 0,
		button: 0,
		ctrlKey: false,
		altKey: false,
		shiftKey: false,
		metaKey: false,
		bubbles: true,
		cancelable: true
	}

	var options = {};  // Object.extend(defaultOptions, arguments[2] || { });
	var oEvent, eventType = null;

	element = $(element);
	if (!element) {
		return;
	}

	for (var name in eventMatchers) {
		if (eventMatchers[name].test(eventName)) {
			eventType = name;
			break;
		}
	}

	if (!eventType) {
		throw new SyntaxError('Only HTMLEvents and MouseEvents interfaces are supported');
	}

	if (document.createEvent) {
		oEvent = document.createEvent(eventType);
		if (eventType == 'HTMLEvents') {
			oEvent.initEvent(eventName, options.bubbles, options.cancelable);
		}
		else {
			oEvent.initMouseEvent(eventName, options.bubbles, options.cancelable, document.defaultView,
				options.button, options.pointerX, options.pointerY, options.pointerX, options.pointerY,
				options.ctrlKey, options.altKey, options.shiftKey, options.metaKey, options.button, element);
		}
		element.dispatchEvent(oEvent);
	}
	else {
		options.clientX = options.pointerX;
		options.clientY = options.pointerY;
		oEvent = document.createEventObject();  // Object.extend(document.createEventObject(), options);
		element.fireEvent('on' + eventName, oEvent);
	}
	return element;
};

/** Repairs various browser event incompatibilities on the given event. */
Events.standardize = function(event) {
	var e = event || window.event;
	if (typeof(e) === "undefined") {
		return e;
	}

	try {
		if (typeof(e.srcElement) === "undefined") {
			e.srcElement = e.target;
		}
		if (typeof(e.target) === "undefined") {
			e.target = e.srcElement;
		}

		if (typeof(e.which) === "undefined") {
			if (typeof(e.button) !== "undefined") {
				e.which = e.button;
			} else if (typeof(e.keyCode) !== "undefined") {
				e.which = e.keyCode;
			} else if (typeof(e.charCode) !== "undefined") {
				e.which = e.charCode;
			}
		}
		if (typeof(e.keyCode) === "undefined") {
			e.keyCode = e.which;
		}
	} catch (ex) {}

	return e;
};

Events.KEY_BACKSPACE   =   8;
Events.KEY_TAB         =   9;
Events.KEY_RETURN      =  13;
Events.KEY_SHIFT       =  16;
Events.KEY_CTRL        =  17;
Events.KEY_ALT         =  18;
Events.KEY_PAUSE       =  19;
Events.KEY_CAPSLOCK    =  20;
Events.KEY_ESCAPE      =  27;
Events.KEY_SPACE       =  32;
Events.KEY_LEFT        =  37;
Events.KEY_UP          =  38;
Events.KEY_RIGHT       =  39;
Events.KEY_DOWN        =  40;
Events.KEY_PGUP        =  33;
Events.KEY_PGDN        =  34;
Events.KEY_END         =  35;
Events.KEY_HOME        =  36;
Events.KEY_INSERT      =  45;
Events.KEY_DELETE      =  46;
Events.KEY_META        =  91;
Events.KEY_CONTEXTMENU =  93;
Events.KEY_F1          = 112;
Events.KEY_F2          = 113;
Events.KEY_F3          = 114;
Events.KEY_F4          = 115;
Events.KEY_F5          = 116;
Events.KEY_F6          = 117;
Events.KEY_F7          = 118;
Events.KEY_F8          = 119;
Events.KEY_F9          = 120;
Events.KEY_F10         = 121;
Events.KEY_F11         = 122;
Events.KEY_F12         = 123;
Events.KEY_SCROLLLOCK  = 145;



/** Frames class has code related to multi-frame pages. */
if (typeof(Forms) === "undefined") {
	function Forms() {}
}

/** Returns an array of all input controls inside a form. */
Forms.getInputs = function(form, nameOnly, tagsToExclude) {
	var result = [];
	var kids = form.getElementsByTagName("*");
	for (var i = 0; i < kids.length; i++) {
		var kid = kids[i];
		if (!DOM.isTagName(kid, "input") && !DOM.isTagName(kid, "textarea") && !DOM.isTagName(kid, "select")) {
			continue;
		}

		if (tagsToExclude && Arrays.contains(tagsToExclude, kid.tagName)) {
			continue;
		}

		if (!nameOnly || kid.name) {
			result.push(kid);
		}
	}

	return result;
};

/** Returns all query parameters within the given form. */
Forms.getQueryParams = function(form) {
	var queryParams = [];
	var currentQueryString = Page.getQueryString();
	if (currentQueryString["debug"]) {
		queryParams["debug"] = "1";
	}

	var kids = Forms.getInputs(form, true);
	for (var i = 0; i < kids.length; i++) {
		var kid = kids[i];
		if (DOM.isTagName(kid, "input") && kid.type == "radio" && !kid.checked) {
			// special case: input type="radio"
			if (!queryParams[encodeURIComponent(kid.name)]) {
				// if this parameter's value is empty, just fill it in with "" as a placeholder
				queryParams[encodeURIComponent(kid.name)] = "";
			}
		} else if (DOM.isTagName(kid, "input") && kid.type == "checkbox" && !kid.checked) {
			// special case: input type="checkbox"
			// if unchecked, shouldn't be included in parameters submitted
		} else {
			queryParams[encodeURIComponent(kid.name)] = kid.value;
		}
	}

	return queryParams;
};

Forms.setEnabled = function(form, enabled, tagsToExclude) {
	var kids = Forms.getInputs(form, false, tagsToExclude);
	for (var i = 0; i < kids.length; i++) {
		var kid = kids[i];
		kid.disabled = !enabled;
	}
};

Forms.setReadOnly = function(form, readonly, tagsToExclude) {
	var kids = Forms.getInputs(form, false, tagsToExclude);
	for (var i = 0; i < kids.length; i++) {
		var kid = kids[i];
		kid.readonly = readonly;
		kid.readOnly = readonly;

//        if (readonly) {
//        } else {
//            delete kid.readonly;
//            delete kid.readOnly;
//        }
	}
};


/** Frames class has code related to multi-frame pages. */
if (typeof(Frames) === "undefined") {
	function Frames() {}
}

Frames.checkLoading = function(event) {
	var w = window;
	while (w && w.parent && w.parent != w) {
		w = w.parent;
	}

	var framesToCheck = ["annotateframe", "scoresheetframe"];
	for (var i = 0; i < framesToCheck.length; i++) {
		var thisFrame = w.frames[framesToCheck[i]];
		if (thisFrame && thisFrame.document &&
			Frames.isLoading(thisFrame.document) && !confirm(
				"Frame '" + framesToCheck[i] + "' is still processing a background task.\n" +
				"If you proceed, your change may be lost.\n" +
				"Are you sure you want to leave this page?")) {
			return Events.abort(event);
		}
	}

	return true;
};

Frames.isLoading = function(doc) {
	var loadingDiv = doc.getElementById("loading");
	var visible = DOM.isVisible(loadingDiv);
	return visible &&
			DOM.getText(loadingDiv).indexOf("...") >= 0 &&
			DOM.getText(loadingDiv).indexOf("Loading") < 0;
};


/** Objects class stores things related to JavaScript objects. */
if (typeof(Objects) === "undefined") {
	function Objects() {}
}

Objects.clearObject = function(obj, includeFunctions) {
	for (var propertyName in obj) {
		try {
			if (!includeFunctions || typeof(obj[propertyName]) != "function") {
				obj[propertyName] = undefined;
			}
			// delete obj[propertyName];
		} catch (e) {}
	}
};

/** A clone of an object is an empty object
 *  with a prototype reference to the original.
 */
Objects.clone = function(obj) {
	// a private constructor, used only by this one clone.
	function Clone() {}
	Clone.prototype = obj;
	return new Clone();
};

Objects.defined = function(variable) {
	return (!(!(variable || false)));
};

/** Creates and returns a "deep copy" of the given object.
 *  You can optionally bound how deep to copy with the levels parameter.
 */
Objects.deepCopy = function(obj, copy, levels) {
	if (typeof(obj) !== "object" || !obj || levels < 1) {
		return obj;
	} else {
		if (!copy) {
			if (Objects.typeOf(obj) == "array") {
				copy = [];
				for (var i = 0; i < obj.length; i++) {
					try {
						// recursively deep-copy each property of this array
						if (obj[i] !== undefined) {
							if (typeof(obj[i]) !== "object" || !obj || levels == 2) {
								copy[i] = obj[i];
							} else {
								copy[i] = Objects.deepCopy(obj[i], undefined, levels - 1);
							}
						}
					} catch (e) {}
				}
			} else {
				// empty object
				copy = {};
				for (var propertyName in obj) {
					try {
						// recursively deep-copy each property of this object
						if (obj[propertyName] !== undefined) {
							if (typeof(obj[propertyName]) !== "object" || !obj || levels == 2) {
								copy[propertyName] = obj[propertyName];
							} else {
								copy[propertyName] = Objects.deepCopy(obj[propertyName], undefined, levels - 1);
							}
						}
					} catch (e) {}
				}
			}
		}
		// special case for array length
		// if (Objects.typeOf(obj) == "array") {
		//  copy.length = obj.length;
		// }

		return copy;
	}
};
var deepCopy = Objects.deepCopy;  // export globally

/** Creates and returns a "shallow copy" of the given object. */
Objects.shallowCopy = function(obj, copy) {
	if (typeof(obj) != "object") {
		return obj;
	} else {
		if (!copy) {
			copy = {};
		}
		for (var propertyName in obj) {
			try {
				// recursively deep-copy each property of this object
				copy[propertyName] = obj[propertyName];
			} catch (e) {}
		}

		// special case for array length
		if (Objects.typeOf(obj) == "array") {
			copy.length = obj.length;
		}

		return copy;
	}
};


/** A fixed version of JavaScript's flawed typeof function.
 *  Now works properly on arrays and null values.
 */
Objects.typeOf = function(value) {
	var s = typeof value;
	if (s === 'object') {
		if (value) {
			if (value instanceof Array) {
				s = 'array';
			}
		} else if (s === null) {
			s = 'null';
		}
	}
	return s;
};


/** Page class stores things related to the web page itself. */
if (typeof(Page) === "undefined") {
	function Page() {}
}

/** Converts a hash of [key -> value] query parameters into a url of form:
 *  key1=value1&key2=value2&...
 */
Page.buildQueryString = function(queryParams) {
	if (!queryParams) {
		queryParams = Page.getQueryString();
	}
	var url = "";
	var first = true;
	for (var key in queryParams) {
		url += (first ? "" : "&") + key + "=" + encodeURIComponent(queryParams[key]);
		first = false;
	}
	return url;
};

/** Adds a hash of [key -> value] query parameters to the given URL and returns it. */
Page.buildUrl = function(baseUrl, queryParams) {
	if (!queryParams) {
		queryParams = Page.getQueryString();
	}
	return baseUrl + "?" + Page.buildQueryString(queryParams);
}

Page.buildCoursesFileUrl = function(queryParams, filenameExtra) {
	// convert relative URLs to absolute, to avoid a Firebug bug with relative URLs
	var url = "courses/" +
		queryParams.course + "/" +
		queryParams.quarter + "/" +
		queryParams.assignment + "/" +
		'files' + "/" +
		queryParams.section + "/" +
		queryParams.student + "/" +
		queryParams.filename;

	if (filenameExtra.length) {
		url += "_" + filenameExtra;
	}

	var path = location.pathname;
	var last = path.lastIndexOf("/");
	if (last >= 0) {
		path = path.substring(0, last + 1);
	}
	// Chop off the admin, if it exists:
	if (path.match(/admin\/$/)) {
		path = path.replace("admin/", "")
	}

	return location.protocol + "//" +
		(location.port ? ":" + location.port : "") +
		(location.hostname ? location.hostname : location.host) +
		path +
		url;
}

/** Clears the contents of the page's 'dump' area. */
Page.clearDump = function() {
	var dumpTarget = $("dumptarget");
	DOM.setText(dumpTarget, "");
};

/** Displays all properties of the given object obj in a 'dump' area on the page. */
Page.dump = function(obj, verbose, append) {
	var dumpTarget = $("dumptarget");
	if (dumpTarget) {
		if (append) {
			DOM.setText(dumpTarget, DOM.getText(dumpTarget) + Page.getDumpText(obj, verbose));
		} else {
			DOM.setText(dumpTarget, Page.getDumpText(obj, verbose));
		}
		dumpTarget.style.display = "block";
		// Page.scrollTo(dumpTarget);
	} else {
		alert(Page.getDumpText(obj, verbose));
	}
};

/** Displays the given text message in the page's 'dumptarget' div. */
Page.dumpError = function(message, isError) {
	if (isError === undefined) {
		isError = true;
	}

	var dumpTarget = $("dumptarget");
	if (dumpTarget) {
		DOM.appendText(dumpTarget, message);
		dumpTarget.style.display = "block";
		if (isError) {
			DOM.addClass(dumpTarget, "errordump");
		} else {
			DOM.removeClass(dumpTarget, "errordump");
		}
		// Page.scrollTo(dumpTarget);
	} else {
		alert(message);
	}
};

/** A placeholder for now; used to put dump text in page perhaps without error styling. */
Page.dumpMessage = function(message) {
	Page.dumpError(message, false);
};

/** Fixes pre block line break problems when injecting innerHTML on IE6
 *  (Internet Explorer sucks!  This is also needed on IE7.)
 */
Page.fixPreLineBreaks = function(text) {
	if (Browser.isIE()) {
		// text = text.replace(/\t/g, "    ");
		// text = text.replace(/ /g, "&nbsp;");
		// text = text.replace(/\n/g, "<br/>\n");
		text = text.replace(/\r/g, "");
		text = "<pre>" + text + "</pre>";
	}
	return text;
};

/** Dynamically creates and POSTs a new form to the given action URL with
 *  the given query parameters.
 */
Page.formPost = function(url, queryParams) {
	if (!queryParams) {
		queryParams = Page.getQueryString();
	}

	var form = document.createElement("form");
	form.action = url;
	form.method = "POST";

	for (var key in queryParams) {
		var input = document.createElement("input");
		input.type = "hidden";
		input.name = key;
		input.value = queryParams[key];
		form.appendChild(input);
	}

	$("dumptarget").appendChild(form);
	form.submit();
};

/** Returns the pixel y-coordinate of the given element on the page. */
Page.getAbsoluteY = function(element) {
	var y = 0;
	while (element && !isNaN(element.offsetTop)) {
		y += element.offsetTop;
		element = element.offsetParent;
	}
	return y;
};

/** Returns a big string of all properties of the given object. */
Page.getDumpText = function(obj, verbose) {
	var text = "";
	if (obj === undefined) {
		text = "undefined";
	} else if (obj === null) {
		text = "null";
	} else if (typeof(obj) == "string") {
		var result = "string(length=" + obj.length + "): \n\"" + obj + "\"";
		if (verbose) {
			// display details about each index and character
			for (var i = 0; i < Math.min(10000, obj.length); i++) {
				if (i % 5 == 0) {
					 result += "\n";
				}
				result += "  " + ("" + i).padL(3) + ": " + obj.charAt(i).toPrintableChar().padL(2) + "    ";
			}
		}
		return result;
	} else if (typeof(obj) != "object") {
		return typeof(obj) + ": " + obj;
	} else {
		text = "object {";
		var props = [];
		for (var prop in obj) {
			props.push(prop);
		}
		props.sort();

		// add each property's name and value to the string
		for (var i = 0; i < props.length; i++) {
			var prop = props[i];
			try {
				if (prop == prop.toUpperCase() && prop.match(/[a-zA-Z]/)) { continue; }  // skips constants; dom objs have lots of them
				text += "\n  " + prop + "=";
				if (prop.match(/innerHTML/)) {
					text += "[inner HTML, omitted]";
				} else if (obj[prop] && ("" + obj[prop]).match(/function/)) {
					text += "[function]";
				} else {
					text += obj[prop];
				}
			} catch (e) {
				text += "error accessing property '" + prop + "': " + e + "\n";
			}
		}

		if (text.charAt(text.length - 1) != "{") {
			text += "\n";
		}
		text += "}";
	}
	return text;
};

/** Returns the current page's HTML query string parameters as a [key -> value] hash. */
Page.getQueryString = function(replacements) {
	var url = window.location.search.substring(1);
	var chunks = url.split(/&/);
	var hash = {};
	for (var i = 0; i < chunks.length; i++) {
		var keyValue = chunks[i].split(/=/);
		if (keyValue[0] && keyValue[1]) {
			// remove annoying query params that UW inserts
			if (keyValue[0].match(/^__ut/)) {
				continue;
			}
			hash[keyValue[0]] = decodeURIComponent(keyValue[1].replace(/\+/g, "%20"));
		}
	}
	if (replacements) {
		for (var key in replacements) {
			hash[key] = replacements[key];
		}
	}
	return hash;
};

/** Returns the current page's HTML query value for the given parameter, else null. */
Page.getQueryParameter = function(name) {
	var url = window.location.search.substring(1);
	var chunks = url.split(/&/);
	for (var i = 0; i < chunks.length; i++) {
		var keyValue = chunks[i].split(/=/);
		if (keyValue[0] == name) {
			return keyValue[1];
		}
	}
	return null;
};

/** Goes back to the previous page, if there is one in the browser's history,
 *  Or else just closes the page window.
 */
Page.goBackOrClose = function(event) {
	if (history.length > 1) {
		// go back
		history.go(-1);
		// AjaxTools.reloadPage();
	} else {
		// close window
		window.close();
	}
	return Events.abort(event);
};

/** Returns true if the given text contains text that is likely an error.
 *  PHP errors and Marty's ERROR: messages are counted.
 */
Page.hasError = function(pageText) {
	return pageText && (
			pageText.match(/<b>Notice<\/b>:/i) ||
			pageText.match(/<b>Fatal error<\/b>:/i) ||
			pageText.match(/<b>Parse error<\/b>:/i) ||
			pageText.match(/<b>Warning<\/b>:/i) ||
			pageText.match(/FATAL ERROR:/) ||
			pageText.match(/HTTP error/) ||
			pageText.match(/Internal Server Error/)
	);
};

/** Hides the 'loading' div on the page, possibly by fading it out. */
Page.loadingHide = function(message, shouldFade) {
	if (!message || (message instanceof XMLHttpRequest)) {
		message = "Successful.";
	}
	var loading = $("loading");
	if (loading) {
		loading.innerHTML = message;

		if (shouldFade === undefined || shouldFade) {
			DOM.fade(loading, 100, 1000);
		} else {
			// user wants to skip fadeout
			loading.style.visibility = "hidden";
		}
	}
};

/** Shows the 'loading' div on the page. */
Page.loadingShow = function(message) {
	var loading = $("loading");
	if (loading) {
		if (message) {
			loading.innerHTML = "<img src=\"" + IMAGE_FOLDER + "/progress_red.gif\" alt=\"progress\" /> &nbsp; " + message;
		}
		loading.style.opacity = 1.0;
		loading.style.visibility = "visible";
		loading.style.display = "block";
	}
};

/** Changes the given form so that its submission will be done via Ajax. */
Page.makeFormIntoAjax = function(formElement, text, refresh, messagePane) {
	if (!formElement) return;
	Events.addEventListener(formElement, "submit", function(event) {
		Events.abort(event);

		// disable the link while loading
		if (formElement.inProgress) {
			formElement.inProgress--;
			return;
		}
		formElement.inProgress = 1;

		AjaxTools.submitForm(formElement, text, function(ajax) {
			formElement.inProgress = undefined;
			if (messagePane) {
				Page.showMessagePane(ajax, refresh);
			} else if (refresh) {
				AjaxTools.reloadPage();
			}
		});
	});
};

/** Changes the given link so that its results will be shown in an Ajax message pane. */
Page.makeLinkIntoAjax = function(linkElement, text, refresh, fn, iframe, suppressMessagePane, maximized, confirmationMessage) {
	if (!linkElement) return;
	Events.addLinkListener(linkElement, function(event) {
		if (!event.shiftKey && !event.ctrlKey) {
			Events.abort(event);

			// Old code passes true as confirmationMessage, we should display a generic message in this case for BC
			confirmationMessage = confirmationMessage === true ? "Are you sure you want to perform this action?" : confirmationMessage;
			if (confirmationMessage && !confirm(confirmationMessage)) {
				return;
			}

			// disable the link while loading
			if (linkElement.inProgress && linkElement.inProgress > 0) {
				linkElement.inProgress--;
				return;
			}
			linkElement.inProgress = 1;   // make them click it 2x if they want to do it again

			var nocache = DOM.hasClass(linkElement, "nocache");

			if (!text) {
				text = "Loading...";
			}
			Page.loadingShow(text);

			if (iframe) {
				Page.showMessageIFrame(linkElement.href, refresh, nocache, maximized);
				linkElement.inProgress = undefined;
				Page.loadingHide();
			} else {
				AjaxTools.fetch(linkElement.href, function(ajax) {
					linkElement.inProgress = undefined;
					if (suppressMessagePane) {
						if (refresh) {
							AjaxTools.reloadPage();
						}
					} else {
						Page.showMessagePane(ajax, refresh, nocache, maximized);
					}
					Page.loadingHide();
					if (fn) {
						fn(ajax);
					}
				});
			}

			return false;
		}
	});
};

Page.makeLinkIntoButton = function(linkElement, fn) {
	if (!linkElement) return;
	linkElement.href = "#";  // so we get the "hand" cursor when hovering on this link
	Events.addEventListener(linkElement, "click", fn);
};

// Saves/loads a cookie remembering your scrollbar position on the current page.
Page.rememberScrollPosition = function() {
	// remember from the cookie and scroll to there
	// cookie's value will be "Xvalue Yvalue"
	var cookieName = "gradeit_scroll_" + window.location.pathname.replace(/.*\//, "");
	if (Cookies.exists(cookieName)) {
		var scrollText = Cookies.get(cookieName);
		var tokens = scrollText.split(/[ ]+/);
		if (tokens.length >= 2) {
			var scrollX = parseInt(tokens[0]);
			var scrollY = parseInt(tokens[1]);
			window.scrollTo(scrollX, scrollY);
		}
	}

	// set up memory to store the cookie when we scroll
	window.onscroll = function() {
		var scrollX = window.scrollX;
		var scrollY = window.scrollY;
		Cookies.set(cookieName, scrollX + " " + scrollY);
	};
};

Page.runningOnLocalhost = function() {
	return location.hostname.match(/localhost/);
};

/** Scrolls the page up or down until the given element is visible. */
Page.scrollTo = function(element, contextElement) {
	if (!element) {
		return;
	}
	if (typeof(element) == "string") {
		element = $(element);
	}

	if (contextElement) {

	} else {
		var elementTop = Page.getAbsoluteY(element);
		var elementBottom = elementTop + element.scrollHeight;
		var windowTop = window.scrollY;
		var windowBottom = windowTop + window.innerHeight;

		var bottomY = elementBottom - window.innerHeight;
		if (elementBottom < windowTop) {
			// window is down below the item; scroll up to it
			window.scroll(window.scrollX, elementTop);
		} else if (elementTop > windowBottom && window.scrollY < bottomY) {
			// window is up above the item; scroll down to it
			window.scroll(window.scrollX, bottomY);
		}
	}
};

/**
 * Pops up a message pane div with an iframe in it showing the given page;
 * optionally refreshes the page when the user closes the message pane.
 */
Page.showMessageIFrame = function(url, refresh, nocache, maximized) {
	if (!url) {
		return;
	}
	Page.loadingHide();

	var div = document.createElement("div");
	div.id = "messagepane";
	div.style.overflow = "hidden";
	div.innerHTML = "<iframe width=\"99%\" height=\"99%\" src=\"" + url + "\" style=\"margin-top: 1em;\"></iframe>";
	if (maximized) {
		div.className = "messagepanetall";
	}

	Page.showMessageHelper(div, refresh, nocache);
};

/**
 * Pops up a message pane div showing the given text in it;
 * optionally refreshes the page when the user closes the message pane.
 */
Page.showMessagePane = function(text, refresh, nocache, maximized) {
	if (!text) {
		return;
	}
	if (text instanceof XMLHttpRequest || (typeof(ActiveXObject) != "undefined" && text instanceof ActiveXObject)) {
		text = text.responseText;
	}
	Page.loadingHide();

	var div = document.createElement("div");
	div.id = "messagepane";
	div.innerHTML = text;
	if (maximized) {
		div.className = "messagepanetall";
	}

	Page.showMessageHelper(div, refresh);
};

/** Common code for both types of message panes/frames. */
Page.showMessageHelper = function(div, refresh, nocache) {
	// maximize link button
	var maximizeButton = document.createElement("a");
	maximizeButton.className = "maximizelink";
	maximizeButton.id = "maximizelink";
	maximizeButton.innerHTML = "<img src=\"" + IMAGE_FOLDER + "/icon_maximize.gif\" alt=\"icon\" />";
	maximizeButton.title = "Maximize / Minimize";
	Page.makeLinkIntoButton(maximizeButton, function(event) {
		if (div.className) {
			div.className = "";
		} else {
			div.className = "messagepanetall";
		}
		return Events.abort(event);
	});

	// close link button
	var button = document.createElement("a");
	button.className = "buttonlink";
	button.innerHTML = "<img src=\"" + IMAGE_FOLDER + "/icon_close.png\" alt=\"icon\" /> Close";

	var removed = false;
	var messagePaneClose = function(event) {
		try {
			if (!removed) {
				removed = true;
				document.body.removeChild(div);
				if (refresh) {
					AjaxTools.reloadPage(undefined, nocache);
				}
				return Events.abort(event);
			}
		} catch (e) {}
	};
	Page.makeLinkIntoButton(button, messagePaneClose);

	var div2 = document.createElement("div");
	div2.id = "messagepaneclosearea";
	div2.appendChild(maximizeButton);
	div2.appendChild(document.createTextNode(" "));
	div2.appendChild(button);
	div.appendChild(div2);

	document.body.appendChild(div);

	document.onkeydown = function(event) {
		try {
			if (!removed && event && event.keyCode == Events.KEY_ESCAPE) {
				messagePaneClose(event);
				document.onkeydown = null;
			}
		} catch (e) {}
	};
};

/**
 * Adds a randomized query parameter to the given URL so that the browser
 * won't try to cache the page.
 */
Page.toUncacheableURL = function(url) {
	if (!url) {
		url = window.location.href;
	}

	var randomNumber = new Date().getTime() + "" + Math.floor(Math.random() * 1000000000);
	url = url.replace(/[?&]dontcacheme=[0-9]+/g, "");
	url += (url.indexOf("?") >= 0 ? "&" : "?") + "dontcacheme=" + randomNumber;
	return url;
};


/* Functions related to string processing. */

/** Returns an HTML-decoded version of the given string. */
String.prototype.htmlDecode = function() {
	var str = this;
	str = str.replace(/&amp;/g, "&");
	str = str.replace(/&lt;/g, "<");
	str = str.replace(/&gt;/g, ">");
	str = str.replace(/&nbsp;/g, " ");
	str = str.replace(/&quot;/g, "\"");
	return str;
};

/** Returns an HTML-encoded version of the given string.
 *  Not very good; just gets the major stuff like < > "
 */
String.prototype.htmlEncode = function(skipSpaces) {
	var str = this;
	str = str.replace(/&/g, "&amp;");
	str = str.replace(/</g, "&lt;");
	str = str.replace(/>/g, "&gt;");
	if (!skipSpaces) {
		str = str.replace(/ /g, "&nbsp;");
	}
	str = str.replace(/\"/g, "&quot;");
	return str;
};

/** Deletes whitespace from the front of the given string. */
if (typeof(String.prototype.ltrim) !== "function") {
	String.prototype.ltrim = function() {
		for (var k = 0; k < this.length && this.charAt(k) <= " "; k++) {}
		return this.substring(k, this.length);
	};
}

/** Inserts spaces at the front of the given string until it reaches the given length,
 *  then returns the padded string.
 */
String.prototype.padL = function(length) {
	var str = this;
	while (str.length < length) {
		str = " " + str;
	}
	return str;
};

/** Inserts spaces at the front of the given string until it reaches the given length,
 *  then returns the padded string.
 */
String.prototype.padR = function(length) {
	var str = this;
	while (this.length < length) {
		str = str + " ";
	}
	return str;
};

/** Deletes whitespace from the end of the given string. */
if (typeof(String.prototype.rtrim) !== "function") {
	String.prototype.rtrim = function() {
		for (var j = this.length - 1; j >= 0 && this.charAt(j) <= " "; j--) {}
		return this.substring(0, j + 1);
	};
}

/** Converts escape sequences into visible characters. */
String.prototype.toPrintableChar = function() {
	if (this == "\n") {
		return "\\n";
	} else if (this == "\r") {
		return "\\r";
	} else if (this == "\t") {
		return "\\t";
	} else {
		return this;
	}
};

/** Deletes whitespace from the front and end of the given string. */
if (typeof(String.prototype.trim) !== "function") {
	String.prototype.trim = function() {
		return this.ltrim().rtrim();
	};
}


/** Test class contains methods related to unit testing. */
if (typeof(Test) === "undefined") {
	function Test() {};
}

/**
 * Checks whether the given boolean condition is truthy.
 * If not, alerts and throws an error.
 */
Test.assert = function(condition, errorMessage) {
	if (!condition) {
		errorMessage = "Assertion failed" + (errorMessage ? (": " + errorMessage) : "") + "\n" +
			"at " + arguments.callee.caller;
		Page.dumpError(errorMessage);
		alert(errorMessage);
		throw new Error(errorMessage);
	}
};

// globally export assert function because it is useful
if (typeof(assert) !== "function") {
	var assert = Test.assert;
}


if (typeof(TextAreaTools) === "undefined") {
	function TextAreaTools() {};
}
TextAreaTools.NBSP_CHAR_CODE = 160;  // character code for non-breaking space (fracking Safari)
TextAreaTools.LINE_SEPARATOR = "\n";
TextAreaTools.LINE_SEPARATOR_OUTPUT = "\n";
TextAreaTools.COLLAPSE_MULTIPLE_SPACES = true;  // treat many spaces as a single space for diffing expressions?
TextAreaTools.SPACES_PER_TAB = 4;
TextAreaTools.TAB_STRING = "    ";
TextAreaTools.DEFAULT_TAB_STRING = TextAreaTools.TAB_STRING;
TextAreaTools.SHOULD_CHECK_LINE_SEPARATOR = true;

// given text running up to cursor, return spaces to put at start of next line.
TextAreaTools.figureIndent = function(str) {
	var eol = str.lastIndexOf(TextAreaTools.LINE_SEPARATOR);
	// eol==-1 works ok
	var line = str.substring(eol + TextAreaTools.LINE_SEPARATOR.length); // take from eol to end
	var indent = "";
	for (var i = 0; i < line.length &&
			(line.charAt(i) == " " || line.charCodeAt(i) == TextAreaTools.NBSP_CHAR_CODE); i++) {
		indent += " ";
	}
	return indent;
}

// Inserts a special character (\n or \t) into the given textarea.
// Original code taken from javabat: http://javabat.com/
// Original author: Nick Parlante
// Modified to work with inserting tabs, shift-tabs (non-IE),
// and to maintain indentation on IE (which it didn't do in javabat).
TextAreaTools.insertCharacter = function(textarea, str, shiftKey) {
	if (textarea.selectionStart !== undefined) {
		// Firefox/Opera/Safari (real browsers)
		var before = textarea.value.substring(0, textarea.selectionStart);
		var indent = TextAreaTools.figureIndent(before);
		var selectionStart = textarea.selectionStart;
		var selectionEnd = textarea.selectionEnd;
		var during = textarea.value.substring(textarea.selectionStart,
				selectionEnd);
		var isMultiLine = selectionStart != selectionEnd; // (during.indexOf(LINE_SEPARATOR) >= 0);
		var after = textarea.value.substring(textarea.selectionEnd,
				textarea.value.length);

		// update the text field
		var scrollTop = textarea.scrollTop; // this inhibits annoying auto-scroll
		var newSelectionStart = 0;
		var newSelectionEnd = 0;

		if (str == TextAreaTools.LINE_SEPARATOR) {
			textarea.value = before + str + indent + after;
			newSelectionStart = newSelectionEnd = selectionEnd + indent.length
					+ TextAreaTools.LINE_SEPARATOR.length;
		} else if (str == TextAreaTools.TAB_STRING) {
			// tab
			if (shiftKey) {
				// remove a tab
				if (isMultiLine) {
					newSelectionStart = selectionStart;
					newSelectionEnd = selectionEnd;
					var lines = during.split(TextAreaTools.LINE_SEPARATOR);
					for (var i = 0; i < lines.length; i++) {
						if (lines[i]) {
							for (var j = 0; j < TextAreaTools.TAB_STRING.length
									&& lines[i].length > 0
									&& lines[i].charAt(0) == TextAreaTools.TAB_STRING.charAt(0); j++) {
								lines[i] = lines[i].substring(1);
								newSelectionEnd--;
							}
						}
					}

					textarea.value = before + lines.join(TextAreaTools.LINE_SEPARATOR) + after;
				} else {
					for (var i = 0; i < TextAreaTools.TAB_STRING.length && before.length > 0
							&& before.charAt(before.length - 1) == TextAreaTools.TAB_STRING.charAt(0); i++) {
						before = before.substring(0, before.length - 1);
					}

					textarea.value = before + after;
					newSelectionStart = newSelectionEnd = selectionEnd - Math.min(i, TextAreaTools.TAB_STRING.length);
				}
			} else {
				// add a tab
				if (isMultiLine) {
					newSelectionStart = selectionStart;
					newSelectionEnd = selectionEnd;
					var lines = during.split(TextAreaTools.LINE_SEPARATOR);
					// alert("multi-line: " + lines.join(" | "));
					for (var i = 0; i < lines.length; i++) {
						if (lines[i]) {
							lines[i] = TextAreaTools.TAB_STRING + lines[i];
							newSelectionEnd += TextAreaTools.TAB_STRING.length;
						}
					}
					textarea.value = before + lines.join(TextAreaTools.LINE_SEPARATOR) + after;
				} else {
					textarea.value = before + TextAreaTools.TAB_STRING + after;
					newSelectionStart = newSelectionEnd = selectionEnd + TextAreaTools.TAB_STRING.length;
				}
			}
		}

		//textarea.focus();
		textarea.selectionStart = newSelectionStart;
		textarea.selectionEnd = newSelectionEnd;
		textarea.scrollTop = scrollTop;

		// we actually did it, so return false
		return false;
	} else if (document.selection && document.selection.createRange) { // IE
		range = document.selection.createRange();
		range_obj = textarea.createTextRange();
		// range_obj = document.selection.createRange();
		range_obj.moveToBookmark(range.getBookmark());
		range_obj.moveEnd('character', textarea.value.length);
		var cursor = textarea.value.length - range_obj.text.length;

		var before = textarea.value.substring(0, cursor);
		// alert("cursor: " + cursor + "\nbefore: '" + before + "'");
		var indent = TextAreaTools.figureIndent(before);
		if (indent == "" && str == TextAreaTools.LINE_SEPARATOR) {
			return true; // let natural event do it -- line 1 IE bug
		}

		range = document.selection.createRange().duplicate();
		range.text = str + (str == TextAreaTools.LINE_SEPARATOR ? indent : "");
		return false;
	}

	return true;
}

TextAreaTools.keyDown = function(event) {
	// for some reason, IE barfs on keypress events and is much better w/ keydown
	if (Browser.isIE() || Browser.isSafari()) {
		return TextAreaTools.keyPress(event);
	}
}

TextAreaTools.keyPress = function(event) {
	var result = true;
	event = Events.standardize(event); // IE sucks
	if (event.keyCode == Events.KEY_RETURN) { // new line, \n
		var result = TextAreaTools.insertCharacter(this, TextAreaTools.LINE_SEPARATOR, false);
	} else if (event.keyCode == Events.KEY_TAB) { // tab, \t
		if (!event.ctrlKey && !event.altKey && !event.metaKey) {
			var result = TextAreaTools.insertCharacter(this, TextAreaTools.TAB_STRING, event.shiftKey);
		}
	} else if (event.keyCode == Events.KEY_ESCAPE) {
		// cycle between \t and "   " for tab on Esc press
		if (!event.ctrlKey && !event.altKey && !event.metaKey) {
			if (TextAreaTools.TAB_STRING == "\t") {
				TextAreaTools.TAB_STRING = TextAreaTools.DEFAULT_TAB_STRING;
			} else {
				TextAreaTools.TAB_STRING = "\t";
			}
		}
	}

	if (!result) { // cancel the event
		Events.abort(event);
	}
	return result;
}

TextAreaTools.makeTextAreaEditor = function(textarea) {
	if (TextAreaTools.SHOULD_CHECK_LINE_SEPARATOR) {
		// this little trick will tell me whether I'm using some funky browser
		// like Opera that replaces all \n with \r\n
		var tempTextArea = document.createElement("textarea");
		tempTextArea.value = TextAreaTools.LINE_SEPARATOR;
		TextAreaTools.LINE_SEPARATOR = tempTextArea.value;
		TextAreaTools.SHOULD_CHECK_LINE_SEPARATOR = false;
	}


	Events.addEventListener(textarea, "keydown", TextAreaTools.keyDown);
	Events.addEventListener(textarea, "keypress", TextAreaTools.keyPress);
};
            </script>

        
            <script type="text/javascript">
                <!-- jsfile = gradeit.js -->
                /** GradeIt class stores things that only Grade-It would ever use. */
if (typeof(GradeIt) === "undefined") {
	function GradeIt() {}
}

/** The width of a text field in an upload form. */
GradeIt.UPLOAD_TEXTFIELD_SIZE = 60;

/** A shared cookie name for whether to initially expand the Resources area. */
GradeIt.SHOW_HIDE_COOKIE_NAME = "cookie_showhide_expanded";


/** Called when a file's Rename link is clicked. */
GradeIt.renameLinkClick = function(event) {
	// find the place on the page with the file's name
	var fileContainer = DOM.enclosingElement("*", "filelineitem", this);
	Test.assert(fileContainer);

	var filepathSpan = DOM.descendent("*", "filepath-container", fileContainer);
	Test.assert(filepathSpan);
	var filepath = DOM.getText(filepathSpan).trim();

	var filenameSpan = DOM.descendent("*", "filename-container", fileContainer);
	Test.assert(filenameSpan);
	var filename = DOM.getText(filenameSpan).trim();

	var newFilepath = prompt("Rename: Full path of destination?", filepath);
	if (newFilepath && newFilepath.trim() != filepath) {
		newFilepath = newFilepath.trim();
		var url = this.href + "&topath=" + newFilepath;

		Page.loadingShow("Renaming...");
		AjaxTools.fetch(url, function(ajax) {
			Page.loadingHide();
			AjaxTools.reloadPage();
		});
	}
	return Events.abort(event);
};

GradeIt.addFileClick = function addFileClick(event) {
	var filename = prompt("File name?");
	if (!filename) {
		return Events.abort(event);
	}
	filename = filename.replace(/[ \t\n]+/g, "");
	var url = this.href + "&filename=" + filename;

	Page.loadingShow("Adding file...");
	AjaxTools.fetch(url, function (ajax) {
		Page.loadingHide();
		AjaxTools.reloadPage();
	});
	return Events.abort(event);
}

GradeIt.addDirectoryClick = function addFileClick(event) {
	Events.abort(event);
	var filename = prompt("Directory name?");
	if (!filename) {
		return Events.abort(event);
	}
	filename = filename.replace(/[ \t\n]+/g, "");
	var url = this.href + "&directoryname=" + filename;

	Page.loadingShow("Adding directory...");
	AjaxTools.fetch(url, function (ajax) {
		Page.loadingHide();
		AjaxTools.reloadPage();
	});
	return Events.abort(event);
}

GradeIt.coverPage = function() {
	var div = document.createElement("div");
	div.id = div.className = "pagecover";
	var img = document.createElement("img");
	img.src = IMAGE_FOLDER + "/progress_rotate_gray.gif";
	img.alt = "wait";
	div.appendChild(img);
	div.appendChild(document.createElement("br"));
	div.appendChild(document.createTextNode("Please wait..."));
	if (document.body.clientHeight) {
		div.style.height = (document.body.clientHeight - 32) + "px";
		div.style.top = "32px";
		div.style.paddingTop = (window.innerHeight / 2 - 20) + "px";
	}
	document.body.appendChild(div);
};

/** Returns true if Grade-It is running in debug mode. */
GradeIt.debugMode = function() {
	var query = Page.getQueryString();
	return query["debug"];
};

/** Called when a file's Delete link is clicked. */
GradeIt.deleteLinkClick = function(event) {
	if (confirm("Delete: Are you sure you want to move this file/folder to the Recycle Bin?")) {
		var url = this.href;

		// find the place on the page with the file's info
		// (might be in a table row or list element)
		var enclosingElement = DOM.enclosingElement("li", "*", this);
		if (!enclosingElement) {
			enclosingElement = DOM.enclosingElement("tr", "*", this);
		}
		Test.assert(enclosingElement);

		Page.loadingShow("Deleting...");
		AjaxTools.fetch(url, function(ajax) {
			DOM.removeMyself(enclosingElement);
			Page.loadingHide();
		});
	}
	return Events.abort(event);
};

/** Navigates to the View Assignment Grade-It page. */
GradeIt.goToAssignmentPage = function() {
	window.location = "assignment_view.php" + window.location.search;
	return false;
};

/** Navigates to the View Quarter Grade-It page. */
GradeIt.goToQuarterPage = function() {
	window.location = "quarter_view.php" + window.location.search;
	return false;
};

/** Navigates to the View Section Grade-It page. */
GradeIt.goToSectionPage = function() {
	window.location = "section_view.php" + window.location.search;
	return false;
};

/** Navigates to the View Student Grade-It page. */
GradeIt.goToStudentPage = function() {
	window.location = "student_view.php" + window.location.search;
	return false;
};

/** Attaches proper listeners to all "ajaxform" forms on this page.
 *  Makes them submit to their action URL in the background using Ajax.
 */
GradeIt.handleAjaxForms = function(root) {
	var ajaxForms = DOM.elementsByClass("form", "ajaxform", root);
	for (var i = 0; i < ajaxForms.length; i++) {
		var refresh = DOM.hasClass(ajaxForms[i], "ajaxrefresh");
		var messagePane = DOM.hasClass(ajaxForms[i], "ajaxmessagepane");
		Page.makeFormIntoAjax(ajaxForms[i], "Submitting...", refresh, messagePane);
	}
};

/** Attaches proper listeners to all "ajaxlink" links on files on this page.
 *  Makes them fetch their target href URL in the background using Ajax.
 */
GradeIt.handleAjaxLinks = function(root) {
	var ajaxLinks = DOM.elementsByClass("a", "ajaxlink", root);
	for (var i = 0; i < ajaxLinks.length; i++) {
		var refresh = DOM.hasClass(ajaxLinks[i], "ajaxrefresh");
		var suppressMessagePane = DOM.hasClass(ajaxLinks[i], "ajaxsuppressmessagepane");
		var iframe = DOM.hasClass(ajaxLinks[i], "ajaxiframe");
		var maximized = DOM.hasClass(ajaxLinks[i], "ajaxmaximized");
		var shouldConfirm = DOM.hasClass(ajaxLinks[i], "ajaxconfirm");
		if (shouldConfirm && ajaxLinks[i].hasAttribute("data-confirmation-message")) {
			shouldConfirm = ajaxLinks[i].getAttribute("data-confirmation-message");
		}
		Page.makeLinkIntoAjax(ajaxLinks[i], "One moment...", refresh, undefined, iframe, suppressMessagePane, maximized, shouldConfirm);
	}
};

/** Attaches proper listeners to all "delete", "rename" links on files on this page. */
GradeIt.handleFileLinks = function(root) {
	var deleteLinks = DOM.elementsByClass("a", "deletelink", root);
	for (var i = 0; i < deleteLinks.length; i++) {
		deleteLinks[i].onclick = GradeIt.deleteLinkClick;
	}

	var renameLinks = DOM.elementsByClass("a", "renamelink", root);
	for (var i = 0; i < renameLinks.length; i++) {
		renameLinks[i].onclick = GradeIt.renameLinkClick;
	}

	var copyLinks = DOM.elementsByClass("a", "copylink", root);
	for (var i = 0; i < copyLinks.length; i++) {
		copyLinks[i].onclick = GradeIt.copyLinkClick;
	}

	var unzipLinks = DOM.elementsByClass("a", "unziplink", root);
	for (var i = 0; i < unzipLinks.length; i++) {
		// Ugly param list:
		Page.makeLinkIntoAjax(
			unzipLinks[i],    // linkEl,
			"Unzipping...",   // message,
			true,             // refresh,
			undefined,        // afterFn,
			false,            // iframe,
			true,             // suppressMsg,
			true,             // maximized
			"Are you sure you want to unzip this file? It will overwrite present files if necessary."
		);
	}

	var javacLinks = DOM.elementsByClass("a", "javaclink", root);
	for (var i = 0; i < javacLinks.length; i++) {
		Page.makeLinkIntoAjax(javacLinks[i], "Compiling...", true);
	}

	var uploadLinks = DOM.elementsByClass("a", "uploadanotherfile", root);
	for (var i = 0; i < uploadLinks.length; i++) {
		Events.addLinkListener(uploadLinks[i], GradeIt.uploadAnotherFileClick);
	}

	Array.forEach(DOM.elementsByClass("*", "addfilelink"), function (elm) {
		Events.addLinkListener(elm, GradeIt.addFileClick);
	});

	Array.forEach(DOM.elementsByClass("*", "adddirectorylink"), function (elm) {
		Events.addLinkListener(elm, GradeIt.addDirectoryClick);
	});
};

/** Makes the Resource Files show/hide links show and hide their nearby divs. */
GradeIt.handleShowHideLinks = function() {
	var links = DOM.elementsByClass("a", "showhidelink");
	for (var i = 0; i < links.length; i++) {
		Events.addLinkListener(links[i], GradeIt.showHideClick);
		links[i].showHideClick = GradeIt.showHideClick;

		// set/get a cookie for each such link
		links[i].cookieName = GradeIt.SHOW_HIDE_COOKIE_NAME + "_" + location.pathname.replace(/.*\//, "") + "_" + i;
		// alert(cookieName);
		if (Cookies.exists(links[i].cookieName)) {
			var cookieValue = Cookies.get(links[i].cookieName);
			if (cookieValue == "true") {
				links[i].showHideClick();   // click the link
				Cookies.set(links[i].cookieName, "true", 999);
			}
		}
	}
};

/** Populates a select box with all tags of a given ID from the given XML response.
 *  e.g. if the XML has a list of <student> tags, puts each student's name into an <option>
 *  HTML tag inside the select box.
 */
GradeIt.list = function(ajax, id, select, sortFunction) {
	if (!select) {
		// select = document.getElementById(type + "select");
		select = document.getElementById(id);
	}

	// removeAllChildren(select);
	// delete all kids except first
	var children = select.getElementsByTagName("option");
	for (var i = children.length - 1; i > 0; i--) {
		select.removeChild(children[i]);
	}

	var root = ajax.responseXML.getElementsByTagName(id + "s")[0];
	var types = root.getElementsByTagName(id);


	var optionArray = [];
	for (var i = 0; i < types.length; i++) {
		optionArray.push(types[i].getAttribute("name"));
	}

	if (sortFunction) {
		optionArray.sort(sortFunction);
	} else {
		optionArray.sort();
	}

	for (var i = 0; i < optionArray.length; i++) {
		var option = document.createElement("option");
		option.value = option.innerHTML = optionArray[i];
		select.appendChild(option);
	}

	Page.loadingHide();
};

/** Called when the user selects a section to move to in section_view.php. */
GradeIt.moveChange = function(event) {
	var section = this.value;
	if (!section) { return; }
	var query = Page.getQueryString();
	if (section == query["section"]) { return; }

	// new section's page
	var newQuery = Page.getQueryString();
	newQuery["section"] = section;

	// figure out student name from hidden span on the page
	var tr = DOM.enclosingElement("tr", "*", this);
	Test.assert(tr);
	var fileNameSpan = DOM.descendent("span", "filename", tr);
	Test.assert(fileNameSpan);
	var fileName = DOM.getText(fileNameSpan);

	query["action"] = "movetosection";
	query["section2"] = section;
	query["student"] = fileName;
	query["turnin"] = "1";

	Page.loadingShow("Moving...");
	AjaxTools.fetch(Page.buildUrl("file_operations.php", query), function(ajax) {
		// once the server is done moving the student, redirect to his/her
		// new page in the new section
		// window.location = Page.buildUrl("section_view.php", newQuery);

		DOM.removeMyself(tr);
		Page.loadingHide();
	});
};

/** A compareTo-style comparison function between two strings
 *  representing quarters such as "07sp" or "06wi".
 */
GradeIt.quarterCompare = function(quarter1, quarter2) {
	var year1 = quarter1.substring(0, 2);
	var year2 = quarter2.substring(0, 2);
	var qtr1 = quarter1.substring(2);
	var qtr2 = quarter2.substring(2);
	var quarters = ["wi", "sp", "su", "au"];

	if (year1 == year2) {
		return Arrays.indexOf(quarters, qtr1) - Arrays.indexOf(quarters, qtr2);
	} else {
		return year1 - year2;
	}
};

/** Called when a file's Rename link is clicked. */
GradeIt.renameLinkClick = function(event) {
	// find the place on the page with the file's name
	var fileContainer = DOM.enclosingElement("*", "filelineitem", this);
	Test.assert(fileContainer);

	var filepathSpan = DOM.descendent("*", "filepath-container", fileContainer);
	Test.assert(filepathSpan);
	var filepath = DOM.getText(filepathSpan).trim();

	var filenameSpan = DOM.descendent("*", "filename-container", fileContainer);
	Test.assert(filenameSpan);
	var filename = DOM.getText(filenameSpan).trim();

	var newFilepath = prompt("Rename: Full path of destination?", filepath);
	if (newFilepath && newFilepath.trim() != filepath) {
		newFilepath = newFilepath.trim();
		var url = this.href + "&topath=" + newFilepath;

		Page.loadingShow("Renaming...");
		AjaxTools.fetch(url, function(ajax) {
			Page.loadingHide();
			AjaxTools.reloadPage();
		});
	}
	return Events.abort(event);
};

/** Called when a file's Copy link is clicked. */
GradeIt.copyLinkClick = function(event) {
	// find the place on the page with the file's name
	var fileContainer = DOM.enclosingElement("*", "filelineitem", this);
	Test.assert(fileContainer);

	var filepathSpan = DOM.descendent("*", "filepath-container", fileContainer);
	Test.assert(filepathSpan);
	var filepath = DOM.getText(filepathSpan).trim();

	var filenameSpan = DOM.descendent("*", "filename-container", fileContainer);
	Test.assert(filenameSpan);
	var filename = DOM.getText(filenameSpan).trim();

	var newFilepath = prompt("Copy: Full path of destination?", filepath);
	if (newFilepath && newFilepath.trim() != filepath) {
		newFilepath = newFilepath.trim();
		var url = this.href + "&topath=" + newFilepath;

		Page.loadingShow("Copying...");
		AjaxTools.fetch(url, function(ajax) {
			Page.loadingHide();
			AjaxTools.reloadPage();
		});
	}
	return Events.abort(event);
};

/** Called when a recycle bin file's Delete link is clicked. */
GradeIt.recycleDeleteLinkClick = function(event) {
	var url = this.href;

	if (confirm("Are you sure you want to permanently delete this file or directory?")) {
		// find the place on the page with the file's info
		// (might be in a table row or list element)
		var enclosingElement = DOM.enclosingElement("*", "file-action-container", this);
		Test.assert(enclosingElement);

		Page.loadingShow("Deleting...");
		AjaxTools.fetch(url, function(ajax) {
			DOM.removeMyself(enclosingElement);
			Page.loadingHide();
		});
	}

	return Events.abort(event);
};

/** Called when a recycle bin file's Restore link is clicked. */
GradeIt.restoreLinkClick = function(event) {
	var url = this.href;

	// find the place on the page with the file's info
	// (might be in a table row or list element)
	var enclosingElement = DOM.enclosingElement("*", "file-action-container", this);
	Test.assert(enclosingElement);

	Page.loadingShow("Restoring...");
	AjaxTools.fetch(url, function(ajax) {
		DOM.removeMyself(enclosingElement);
		Page.loadingHide();
	});
	return Events.abort(event);
};

/** Called by assignment/quarter pages to show or hide Resource Files sections. */
GradeIt.showHideClick = function(event) {

	var node = this;
	var div = DOM.sibling("*", "showhidearea", node);
	while (!div) {
		node = node.parentNode;
		if (!node.parentNode) {
			Test.assert(false, "Unable to find sibling showhidearea up the tree from " + this)
		}
		div = DOM.sibling("*", "showhidearea", node);
	}
	DOM.toggleDisplay(div);

	var showHideIdentifiers = DOM.children("span", "showhideunique", this);
	if (showHideIdentifiers && showHideIdentifiers.length == 1) {
		var showHideIdentifierSpan = showHideIdentifiers[0];
		var showHideUniqueClass = showHideIdentifierSpan.innerHTML;
		var showHidePartners = DOM.children("*", showHideUniqueClass, this.parentNode);

		Array.forEach(showHidePartners, function(node) {
			var expandedIndicator = DOM.children("*", "expandedindicator", node);
			DOM.toggleClass(expandedIndicator, "expanded");
		});
	}

	// cookie to remember it for next time
	if (Cookies.exists(this.cookieName) && Cookies.get(this.cookieName) == "true") {
		// Cookies.remove(this.cookieName);
		Cookies.set(this.cookieName, "false", 999);
	} else {
		Cookies.set(this.cookieName, "true", 999);
	}

	return Events.abort(event);
};

/** Called when user clicks "add another file" on a file upload form. */
GradeIt.uploadAnotherFileClick = function(event) {
	// <input id="upload_file2" type="file" name="assignment_file2" />
	var input = document.createElement("input");

	// figure out how many files currently exist
	var form = DOM.enclosingElement("form", "*", this);
	Test.assert(form);
	var filesArea = DOM.elementByClass("div", "uploadfilesarea", form);
	Test.assert(filesArea);
	var fileDivs = filesArea.getElementsByTagName("div");
	var files = fileDivs.length + 1;

	input.type = "file";
	input.size = GradeIt.UPLOAD_TEXTFIELD_SIZE;
	input.id = "upload_file" + files;
	input.name = "upload_file" + files;

	var remove = document.createElement("a");
	remove.href = "";
	remove.innerHTML = "remove";
	remove.onclick = GradeIt.uploadRemoveClick;

	var div = document.createElement("div");
	div.appendChild(input);
	div.appendChild(document.createTextNode(" "));
	div.appendChild(remove);

	filesArea.appendChild(div);

	return Events.abort(event);
};

GradeIt.uploadRemoveClick = function(event) {
	var div = this.parentNode;
	div.parentNode.removeChild(div);
	return Events.abort(event);
};

// Email Validation Javascript
// copyright 23rd March 2003, by Stephen Chapman, Felgall Pty Ltd

// You have permission to copy and use this javascript provided that
// the content of the script is not changed in any way.

GradeIt.validateEmailAddress = function(addr, debug) {
	addr = addr.htmlEncode();
	if (addr == '' && man) {
		if (debug) {
			// alert('Invalid UW NetID: ' + ': ' + 'email address is mandatory');
		}
		return false;
	}
	if (addr == '') return true;
	var invalidChars = '\/\'\\ ";:?!()[]\{\}^|';
	for (i=0; i<invalidChars.length; i++) {
		if (addr.indexOf(invalidChars.charAt(i),0) > -1) {
			if (debug) {
				// alert('Invalid UW NetID: email address contains invalid characters');
			}
			return false;
		}
	}
	for (i=0; i<addr.length; i++) {
		if (addr.charCodeAt(i)>127) {
			if (debug) {
				// alert("Invalid UW NetID: email address contains non ascii characters.");
			}
			return false;
		}
	}

	var atPos = addr.indexOf('@',0);
	if (atPos == -1) {
		if (debug) {
			// alert('Invalid UW NetID: email address must contain an @');
		}
		return false;
	}
	if (atPos == 0) {
		if (debug) {
			// alert('Invalid UW NetID: email address must not start with @');
		}
		return false;
	}
	if (addr.indexOf('@', atPos + 1) > - 1) {
		if (debug) {
			// alert('Invalid UW NetID: email address must contain only one @');
		}
		return false;
	}
	if (addr.indexOf('.', atPos) == -1) {
		if (debug) {
			// alert('Invalid UW NetID: email address must contain a period in the domain name');
		}
		return false;
	}
	if (addr.indexOf('@.',0) != -1) {
		if (debug) {
			// alert('Invalid UW NetID: period must not immediately follow @ in email address');
		}
		return false;
	}
	if (addr.indexOf('.@',0) != -1){
		if (debug) {
			// alert('Invalid UW NetID: period must not immediately precede @ in email address');
		}
		return false;
	}
	if (addr.indexOf('..',0) != -1) {
		if (debug) {
			// alert('Invalid UW NetID: two periods must not be adjacent in email address');
		}
		return false;
	}
	var suffix = addr.substring(addr.lastIndexOf('.')+1);
	if (suffix.length != 2 && suffix != 'com' && suffix != 'net' && suffix != 'org' && suffix != 'edu' && suffix != 'int' && suffix != 'mil' && suffix != 'gov' & suffix != 'arpa' && suffix != 'biz' && suffix != 'aero' && suffix != 'name' && suffix != 'coop' && suffix != 'info' && suffix != 'pro' && suffix != 'museum') {
		if (debug) {
			// alert('Invalid UW NetID: invalid primary domain in email address');
		}
		return false;
	}
	return true;
}

/** Returns true if the element with given ID has non-empty contents. */
GradeIt.validateNonEmpty = function(id, name, event) {
	var element = $(id);
	if (element) {
		var text = element.value;
		if (!text || !text.trim()) {
			// alert(name + " must not be blank.");
			DOM.addClass(element, "invalid");
			if (event) {
				Events.abort(event);
			}
			return false;
		} else {
			// remove yellow highlight if it was there
			DOM.removeClass(element, "invalid");
		}
	}
	return true;
};

/** Makes sure student ID is 7 digits.
 *  Returns true if it is, false (and aborts event) if not.
 */
GradeIt.validateSid = function(inputBoxId, event) {
	if (!GradeIt.validateNonEmpty(inputBoxId, "Student ID Number")) {
		return Events.abort(event);
	}

	var sidField = $(inputBoxId);
	if (sidField && !sidField.value.match(/^\d{7}$/) && !sidField.value.match(/^unknown$/) ) {
		DOM.addClass(sidField, "invalid");
		// alert("Student ID Number must be exactly 7 digits.");
		return Events.abort(event);
	}

	return true;
};

// make the page set up any important links
Events.addOnLoad(function() {
    GradeIt.handleShowHideLinks();
    GradeIt.handleFileLinks();
    GradeIt.handleAjaxLinks();
    GradeIt.handleAjaxForms();
});
            </script>

        
            <script type="text/javascript">
                <!-- jsfile = scoresheet_common.js -->
                // JS code shared by both the scoresheet and the printview pages
// (which potentially shows multiple score sheets).
// NOTE: This code intentionally doesn't use the 'module' pattern (wrapping all
// code inside a big anonymous function to create a private scope) because these
// functions and variables are to be shared with other .js files.

var maxId = 0;
var scoresheetComplete = false;    // whether all items are filled in

// if skipUpdate is true, doesn't actually change the value in the fields
function computeTotal(skipUpdate) {
	scoresheetComplete = true;   // will be set back to false during traversal if not done
	
	var roots = DOM.elementsByClass("li", "total");
	var totalMax;
	for (var i = 0; i < roots.length; i++) {
		totalMax = computeTotalR(roots[i], skipUpdate);
	}
	return totalMax;
}

// recursive score total
// root is assumed to be a <li> of class "category" or "item", and must have:
// a direct child <span class="total">
// a direct child <span class="max">
// a direct child
function computeTotalR(root, skipUpdate) {
	if (root.id && root.id > maxId) { maxId = root.id; }

	var totalMax = {total : 0, max : 0, min : 0};

	if (DOM.hasClass(root, "item")) {
		var maxElement = DOM.elementByClass("*", "itemmax", root);
		var max = Number(DOM.elementValue(maxElement));
		if (!isNaN(max)) {
			totalMax.max = max;
		}

		var minElement = DOM.elementByClass("*", "itemmin", root);
		var min = 0;
		if (minElement) {
			min = Number(DOM.elementValue(minElement));
			if (!isNaN(min)) {
				totalMax.min = min;
			}
		}

		var scoreElement = DOM.elementByClass("*", "score", root);
		if (scoreElement) {
			var scoreText = DOM.elementValue(scoreElement);
			var score = Number(scoreText);
			if (isNaN(score)) {
				if (!isNaN(max) && max > 0) {
					// a category that isn't filled out
					scoresheetComplete = false;
				}
			} else {
				totalMax.total = score;
			}

			// color red if not valid value
			ensureValidValue(scoreElement, scoreText, min, max);
		}
	} else if (DOM.hasClass(root, "category")) {
		// var name = DOM.elementByClass("span", "categoryname", root).innerHTML;
		var categoryList = DOM.child("ul", "category", root);
		if (categoryList && categoryList.id && categoryList.id > maxId) { maxId = categoryList.id; }

		var categories = DOM.children("*", "category", categoryList);
		var items = DOM.children("*", "item", categoryList);
		categories = categories.concat(items);

		// retursively process items inside this category
		for (var i = 0; i < categories.length; i++) {
			var categoryTotalMax = computeTotalR(categories[i], skipUpdate);
			totalMax.total += categoryTotalMax.total;
			totalMax.max   += categoryTotalMax.max;

			// some items (e.g. lateness deduction) have a negative "min" value;
			// this should affect the enclosing category (lateness)'s min,
			// but not mins further up the chain
			if (DOM.hasClass(categories[i], "item")) {
				totalMax.min += categoryTotalMax.min;
			}
		}

		// HACKS to fix double addition (0.2 + 0.1 = 0.300000004, etc)
		totalMax.max = Math.round(totalMax.max * 100000) / 100000;
		totalMax.min = Math.round(totalMax.min * 100000) / 100000;
		totalMax.total = Math.round(totalMax.total * 100000) / 100000;

		// put total into the page
		var totalElement = DOM.child("*", "categorytotal", root);
		if (totalElement && skipUpdate !== true) {
			if (totalMax.max == 0 && totalMax.total == 0) {
				totalElement.innerHTML = "";
			} else {
				totalElement.innerHTML = "" + totalMax.total;
			}
		}

		var maxSpan = DOM.child("span", "categorymax", root);
		if (totalMax.max != 0 && maxSpan && skipUpdate !== true) {
			maxSpan.innerHTML = "" + totalMax.max;
		}
		if (totalMax.max == 0) {
			maxSpan.style.visibility = "hidden";
			var slash = DOM.child("*", "slash", root);
			if (slash) {
				slash.style.visibility = "hidden";
			}

			var colon = DOM.child("*", "colon", root);
			if (colon) {
				if (totalMax.total != 0) {
					colon.style.visibility = "visible";
				} else {
					colon.style.visibility = "hidden";
				}
			}
		} else if (maxSpan.style.visibility == "hidden") {
			maxSpan.style.visibility = "visible";
			var slash = DOM.child("*", "slash", root);
			if (slash) {
				slash.style.visibility = "visible";
			}
		}

		ensureValidValue(totalElement, totalMax.total, totalMax.min, totalMax.max);
	}

	return totalMax;
}

function ensureValidValue(element, score, min, max) {
	if ((score == null || score == undefined || score == "") || 
			(!isNaN(score) && (max == 0 || (score >= min && score <= max)))) {
		element.style.color = null;
	} else {
		element.style.color = "red";
	}
}

function hasChangedDocument() {
	return hasChanged(document);
}

function hasChanged(element) {
	var inputs = element.getElementsByTagName("input");
	for (var i = 0; i < inputs.length; i++) {
		if ((DOM.hasClass(inputs[i], "score") ||
				DOM.hasClass(inputs[i], "editablemax") ||
				DOM.hasClass(inputs[i], "editablename") ||
				DOM.hasClass(inputs[i], "editabledescription")) &&
				inputs[i].oldValue != undefined && inputs[i].value != undefined &&
				inputs[i].oldValue != inputs[i].value) {
			return true;
		}
	}
	return false;
}

function inputKeyPress(event) {
	event = Events.standardize(event);

	key = event.keyCode || event.which;
	if (key == 13) {  // user pressed Enter
		computeTotal();

		// don't let form submit
		return Events.abort(event);
	}
}

function scoresheetCloseClick(event, fn) {
	Events.abort(event);
	
	var changed = hasChangedDocument();
	if (!changed ||
			confirm("You have unsaved changes.\nAre you sure you want to close?")) {
		if (fn) {
			return fn(event);
		}
	} else {
		return Events.abort(event);
	}
}

// Returns whether the TA is done filling out this score sheet.
function scoresheetIsComplete() {
	return scoresheetComplete;
}

// Updates every input text box's "old value" so that I can tell later whether
// Any input values have changed.
function updateOldValues(inputs) {
	if (!inputs) {
		var inputs = document.getElementsByTagName("input");
	}
	for (var i = 0; i < inputs.length; i++) {
		inputs[i].oldValue = inputs[i].value;
	}
}

function visit(root, fn, includeItems, preOrder) {
	if (DOM.hasClass(root, "item") && includeItems) {
		fn(root);
	} else if (DOM.hasClass(root, "category")) {
		if (preOrder) {
			fn(root);
		}

		var categoryList = DOM.child("ul", "category", root);
		var categories = DOM.children("*", "category", categoryList);

		if (includeItems) {
			var items = DOM.children("*", "item", categoryList);
			categories = categories.concat(items);
		}

		// retursively process items inside this category
		for (var i = 0; i < categories.length; i++) {
			visit(categories[i], fn, includeItems);
		}

		if (!preOrder) {
			fn(root);
		}
	}
}
            </script>

        
            <script type="text/javascript">
                <!-- jsfile = scoresheet.js -->
                (function() {
	// disable total late days box unless nearby checkbox checked
	// js event handler, when box is (un)checked, en/disable input box
	// calculate new total late days used

	var TA_NAME_COOKIE_NAME = "cookie_ta_name";
	var POST_TO_GRADES_DB_COOKIE_NAME = "cookie_posttogradesdb_checked";
	var PUBLISH_TO_WEBSITE_COOKIE_NAME = "cookie_publish_checked";
	var PUBLISH_TO_WEBSITE_LATER_COOKIE_NAME = "cookie_publish_whengraded_checked";
	var PUBLISH_NEVER_COOKIE_NAME = "cookie_publish_never_checked";
	var SHOW_GRADER_NOTES_COOKIE_NAME = "cookie_showgradernotes_checked";
	var PREVIOUS_COMMENTS_COOKIE_NAME = "cookie_previouscomments";
	var SAVE_PAST_COMMENTS_COOKIE_NAME = "cookie_savepastcomments";
	var MAX_PREVIOUS_COMMENT_LENGTH = 20;       // length before ... shown in select box
	var MAX_PREVIOUS_TOTAL_LENGTH = 1024;       // max length of one comment before truncated
	var MAX_COMMENTS_PER_CATEGORY = 99;         // max # of comments about one grade category
	var MAX_TOTAL_PREVIOUS_COMMENTS = 999;      // max # of comments about all categories combined
	var COOKIE_EXPIRE = 10;                     // how many days to keep some temporary cookies

	Events.addOnLoad(function() {
		Page.makeLinkIntoButton($("fillMax"), fillMaxClick);
		Page.makeLinkIntoButton($("fillMin"), fillMinClick);
		Page.makeLinkIntoButton($("fillcheat"), fillCheatClick);
		Page.makeLinkIntoButton($("clear"), clearClick);
		Page.makeLinkIntoButton($("scoresheetsavebutton"), scoresheetSaveClick);
		Page.makeLinkIntoButton($("scoresheetcancelbutton"), scoresheetCancelClick);
		Page.makeLinkIntoButton($("scoresheetdeletebutton"), deleteScoreSheet);
		Page.makeLinkIntoButton($("backread-email-button"), backreadEmailClick);
		if ($("previouslink")) {
			Events.addEventListener($("previouslink"), "click", prevNextClick);
		}
		if ($("nextlink")) {
			Events.addEventListener($("nextlink"), "click", prevNextClick);
		}

		// auto-fill-in when blank TA name encountered (190m feature)
		var graderBoxes = DOM.elementsByClass("input", "grader");
		for (var i = 0; i < graderBoxes.length; i++) {
			if (!graderBoxes[i].value) {
				Cookies.makeTextBoxStateful(graderBoxes[i], TA_NAME_COOKIE_NAME, COOKIE_EXPIRE);
			}
		}

		// render grader notes
		var gradernotes = document.querySelectorAll("div.gradernote");
		var converter = new showdown.Converter();
		converter.setFlavor('github');
		for (var i = 0; i < gradernotes.length; i++) {
			gradernotes[i].innerHTML = converter.makeHtml(gradernotes[i].innerHTML);
		}

		if ($("publish")) {
			Cookies.makeRadioButtonStateful($("publish"), PUBLISH_TO_WEBSITE_COOKIE_NAME);
			Cookies.makeRadioButtonStateful($("publishwhengraded"), PUBLISH_TO_WEBSITE_LATER_COOKIE_NAME);
			Cookies.makeRadioButtonStateful($("publishnever"), PUBLISH_NEVER_COOKIE_NAME);
			Events.addEventListener($("publish"), "change", publishChange);
		}
		if ($("showgradernotes")) {
			Events.addEventListener($("showgradernotes"), "click", showGraderNotesClick);  // must come before makeCheckboxStateful call
			Cookies.makeCheckboxStateful($("showgradernotes"), SHOW_GRADER_NOTES_COOKIE_NAME, COOKIE_EXPIRE);

			showGraderNotesClick();
		}
		if ($("posttogradesdb")) {
			Cookies.makeCheckboxStateful($("posttogradesdb"), POST_TO_GRADES_DB_COOKIE_NAME, COOKIE_EXPIRE);
		}

		if ($("postlatedaystogradesdb")) {
			Events.addEventListener($("postlatedaystogradesdb"), "click", postLateDaysToGradesDbClick);
			postLateDaysToGradesDbClick();
		}

		if ($("postearlydaystogradesdb")) {
			Events.addEventListener($("postearlydaystogradesdb"), "click", postEarlyDaysToGradesDbClick);
			postEarlyDaysToGradesDbClick();
		}

		if ($("backread")) {
			Events.addEventListener($("backread"), "change", backreadChange);
		}

		// set up handlers to recompute score when a category's value changes
		var inputs = DOM.elementsByClass("input", "score");
		for (var i = 0; i < inputs.length; i++) {
			Events.addEventListener(inputs[i], "blur", computeTotal);
			Events.addEventListener(inputs[i], "keypress", inputKeyPress);
		}

		var commentLinks = DOM.elementsByClass("a", "addcommentlink");
		for (var i = 0; i < commentLinks.length; i++) {
			Events.addEventListener(commentLinks[i], "click", commentLinkClick);
		}

		var commentSpyLinks = DOM.elementsByClass("a", "commentspylink");
		for (var i = 0; i < commentSpyLinks.length; i++) {
			Events.addEventListener(commentSpyLinks[i], "click", commentSpyClick);
		}

		var inputs = document.getElementsByTagName("input");
		updateOldValues(inputs);
		for (var i = 0; i < inputs.length; i++) {
			Events.addEventListener(inputs[i], "keypress", Events.abortFormSubmit);
		}

		// auto-resizing text area
		// var textareas = DOM.elementsByClass("textarea", "comments");
		// for (var i = 0; i < textareas.length; i++) {
			// Events.addEventListener(textareas[i], "keyup", commentsKeyDown);
		// }

		// handler so that when late days used is changed, checks box to submit them
		var inputs = DOM.elementsByClass("input", "latedaysused");
		for (var i = 0; i < inputs.length; i++) {
			Events.addEventListener(inputs[i], "focus", lateDaysUsedOnFocus);
			Events.addEventListener(inputs[i], "blur", checkLateDaySubmitBox);
			inputs[i].oldValueSubmitted = inputs[i].value;
		}

		// handler so that when early days is changed, checks box to submit them
		var inputs = DOM.elementsByClass("input", "earlydays");
		for (var i = 0; i < inputs.length; i++) {
			Events.addEventListener(inputs[i], "focus", lateDaysUsedOnFocus);
			Events.addEventListener(inputs[i], "blur", checkEarlyDaySubmitBox);
			inputs[i].oldValueSubmitted = inputs[i].value;
		}

		var selects = DOM.elementsByClass("select", "previouscomments");
		for (var i = 0; i < selects.length; i++) {
			Events.addEventListener(selects[i], "change", previousCommentsChange);
		}

		if ($("savepastcomments")) {
			Cookies.makeCheckboxStateful($("savepastcomments"), SAVE_PAST_COMMENTS_COOKIE_NAME, COOKIE_EXPIRE);
			if ($("savepastcomments").checked) {
				getAllPreviousComments();
			}
		}

		var params = Page.getQueryString();
		if (params["moss"]) {
			if ($("showgradernotes")) {
				$("showgradernotes").checked = false;
			}
			showGraderNotesClick();
		}

		computeTotal();

		if ($("gradingtimer")) {
			$("gradingtimer").style.visibility = "visible";  // show it
		}
		setInterval(updateGradingTimer, 60*1000);

		$("scoresheetsavebutton").focus();
		Page.rememberScrollPosition();
	});

	function backreadChange(event) {
		if (this.checked) {
			$("publishnever").checked = true;
			$("backread-container").style.display = "inline";
		} else {
			$("backread-container").style.display = "none";
		}
	}

	function backreadEmailClick(event) {
		if ($("backread").checked &&
			!confirm("You indicated that you want someone (head TA or instructor) to back-read this student.  " +
				"This action will send an email the course's head TA(s) and/or instructors asking them to look" +
				" at this student.  Are you sure?")) {
			return Events.abort(event);
		}

		document.querySelector("#backread-email input[name=backreadcomments]").value = $("backreadcomments").value;
		AjaxTools.submitForm($("backread-email"), "Emailing head ta...");
		return Events.abort(event);
	}

	function checkEarlyDaySubmitBox(event) {
		if (this.oldValue != this.value) {
			$("postearlydaystogradesdb").checked = true;
			postEarlyDaysToGradesDbClick();
			var totalEarlyDaysEarned = parseInt($("gradesdbearlydaysearned").value);
			var earlyDaysEarnedBox = DOM.elementByClass("input", "earlydays");
			if (earlyDaysEarnedBox) {
				var earlyDaysEarnedThisHW = parseInt(earlyDaysEarnedBox.value) || 0;
				var prevEarlyDaysEarnedThisHW = parseInt(earlyDaysEarnedBox.oldValueSubmitted) || 0;   // default 0
				earlyDaysEarnedBox.oldValueSubmitted = earlyDaysEarnedThisHW;
				totalEarlyDaysEarned += earlyDaysEarnedThisHW - prevEarlyDaysEarnedThisHW;
				$("gradesdbearlydaysearned").value = totalEarlyDaysEarned;
			}
		}
	}

	function checkLateDaySubmitBox(event) {
		if (this.oldValue != this.value) {
			$("postlatedaystogradesdb").checked = true;
			postLateDaysToGradesDbClick();

			var totalLateDaysUsed = parseInt($("gradesdblatedaysused").value) || 0;
			var lateDaysUsedBox = DOM.elementByClass("input", "latedaysused");
			if (lateDaysUsedBox) {
				var lateDaysUsedThisHW = parseInt(lateDaysUsedBox.value) || 0;
				var prevLateDaysUsedThisHW = parseInt(lateDaysUsedBox.oldValueSubmitted) || 0;   // default 0
				lateDaysUsedBox.oldValueSubmitted = lateDaysUsedThisHW;

				totalLateDaysUsed += lateDaysUsedThisHW - prevLateDaysUsedThisHW;
				$("gradesdblatedaysused").value = totalLateDaysUsed;
			}
		}
	}

	function clearClick(event) {
		fillCriteria("clear");
		return Events.abort(event);
	}

	// returns cookie string name for given text field name
	function commentCookieName(name) {
		var result = PREVIOUS_COMMENTS_COOKIE_NAME + "_";

		var params = Page.getQueryString();
		if (params["course"]) {
			result += params["course"] + "_";
		}
		//if (params["quarter"]) {
		//	result += params["quarter"] + "_";
		//}
		if (params["assignment"]) {
			result += params["assignment"] + "_";
		}

		result += name;
		return result;
	}

	function commentLinkClick(event) {
		var commentsArea = DOM.sibling("*", "commentsarea", this);
		if (commentsArea) {
			DOM.toggleDisplay(commentsArea);
			/*
			if (commentsArea.style.display == "none") {
				commentsArea.style.display = "";
			} else {
				commentsArea.style.display = "none";
			}
			*/
		}
		return Events.abort(event);
	}

	function commentsKeyDown(event) {
		var height = this.value.split(/\r?\n/).length;
		this.rows = height;
		var guessHeight = (0.25 + 1.25 * height);
		this.style.height = guessHeight + "em";  // rough guess
		//if (this.offsetHeight && guessHeight < this.offsetHeight) {
		//	this.style.height = this.offsetHeight;
		//}
	}

	function commentSpyClick(event) {
		// var commentsArea = DOM.sibling("*", "commentsarea", this);
		// var commentSpySpan = DOM.child("*", "commentspy", commentsArea);
		var commentSpySpan = DOM.sibling("*", "commentspy", this);
		var score = DOM.sibling("*", "score", this);
		if (commentSpySpan && score) {
			if (commentSpySpan.style.display == "none") {
				commentSpySpan.innerHTML = "Loading... (<a target=\"_blank\" href=\"" + this.href + "&amp;all=1\">see ALL comments</a>)";
				commentSpySpan.style.display = "block";

				var query = Page.getQueryString();
				// query["category"] = score.getAttribute("name");

				// fetch commentspy data and put it in the page
				AjaxTools.fetch(this.href, function(ajax) {
					commentSpySpan.innerHTML = ajax.responseText;
				});
			} else {
				commentSpySpan.style.display = "none";
			}
		}
		return Events.abort(event);
	}

	// make sure that late days tallied add up to amount of lateness for the assignment
	function confirmLateness(event) {
		var lateDaysUsed = 0;
		var lateDaysNegative = false;
		var latenessDeductions = 0;
		var latenessDeductionPositive = false;
		var lateTotal = 0;
		var inputs = DOM.elementsByClass("input", "latedaysused");
		for (var i = 0; i < inputs.length; i++) {
			var value = parseInt(inputs[i].value) || 0;
			if (value < 0) {
				lateDaysNegative = true;
			}

			lateDaysUsed += value;
			lateTotal += value;
		}

		var earlyDaysEarned = 0;
		var inputs = DOM.elementsByClass("input", "earlydays");
		for (var i = 0; i < inputs.length; i++) {
			var value = parseInt(inputs[i].value) || 0;
			if (!isNaN(value)) {
				earlyDaysEarned += value;
			}
		}

		// default of -1 but can be overridden by the sections.xml file info
		var latenessPenaltyPerDay = -1;
		if ($("latenessdeductionperday")) {
			latenessPenaltyPerDay = parseInt($("latenessdeductionperday").innerHTML) || 0;
		}
		inputs = DOM.elementsByClass("input", "latenessdeduction");
		for (var i = 0; i < inputs.length; i++) {
			var value = parseInt(inputs[i].value) || 0;
			if (value > 0) {
				latenessDeductionPositive = true;
			}

			latenessDeductions += value;
			lateTotal += value / latenessPenaltyPerDay;   // really subtracting; but since it's negative, add
		}

		var lateOughtToBe = 0;
		var latespans = DOM.elementsByClass("span", "latesubmission");
		for (var i = 0; i < latespans.length; i++) {
			// "(3 days late)" -> "3 days late" -> 3
			var count = parseInt(latespans[i].innerHTML.replace(/[()]+/g, "")) || 0;
			if (count > 0 || count < 0) {
				lateOughtToBe += count;
			}
		}
		// account for usage of early days to cover for lateness
		// (2 early days per late day)
		if (earlyDaysEarned < 0) {
			lateOughtToBe += earlyDaysEarned / 2;
		}

		var earlyOughtToBe = 0;
		var earlyspans = DOM.elementsByClass("span", "earlysubmission");
		for (var i = 0; i < earlyspans.length; i++) {
			// "(on time, 3 days early)" -> "3 days early" -> 3
			var count = parseInt(earlyspans[i].innerHTML.replace(/.*, /g, "")) || 0;
			if (count > 0 || count < 0) {
				earlyOughtToBe += count;
			}
		}

		var errorMsg = "";
		if (lateDaysNegative) {
			errorMsg += "You entered a negative value for Late Days Used for this student (" + lateDaysUsed + ").  " +
					"Except in rare cases, late days used should always be a non-negative value.  " +
					"Entering a negative Late Days Used value actually gives the student MORE late days.\n\n";
		}

		if (latenessDeductionPositive) {
			errorMsg += "You entered a positive value for Lateness Deduction for this student (" + latenessDeductions + ").  " +
					"Lateness deductions should always be either 0 or a negative number.  " +
					"Entering a positive value actually rewards the student with MORE points on their homework.\n\n";
		}

		if (lateTotal != lateOughtToBe) {
			errorMsg += "You deducted the following for lateness:\n\n" +
					"  * " + lateDaysUsed + " late day(s) used (must be 0 or POSITIVE)\n" +
					"  * " + latenessDeductions + " point(s) lateness deduction (" + (value / latenessPenaltyPerDay) + " days' worth of penalty); must be 0 or NEGATIVE)\n" +
					"---------------------------------------------------\n" +
					"  * " + lateTotal + " TOTAL DAYS' WORTH OF PENALTY\n\n" +
					"But this does not equal the amount of lateness from the submission:\n\n" +
					"  * " + lateOughtToBe + " day(s) late\n\n";
		}

		// looser matching for early days; just needs to be > 0
		if (earlyOughtToBe > 0 && earlyDaysEarned <= 0) {
			errorMsg += "You didn't award any early days,\n" +
					"But the submission is " + earlyOughtToBe + " days early.\n\n";
		}
		if (errorMsg.length > 0) {
			if (!confirm(
					"Warning: You have potential problems with the lateness data for this student:\n\n" +
					errorMsg +
					"Are you sure you want to submit it this way?  " +
					"Press Cancel if you want to go back and correct the lateness before submitting.")) {
				return Events.abort(event);
			}
		}

		return true;
	}

	function deleteScoreSheet(event) {
		if (confirm("Are you sure you want to delete this student's score sheet data?")) {
			// send the clearing to the server
			var query = Page.getQueryString();
			AjaxTools.fetch(Page.buildUrl("scoresheet_delete.php", query), function(ajax) {
				fillCriteria("clear", true);
				location.reload();
			});
		}

		return Events.abort(event);
	}

	function fillCheatClick(event) {
		Events.abort(event);
		var descriptions = DOM.elementsByClass("span", "description");
		for (var i = 0; i < descriptions.length; i++) {
			if (DOM.getText(descriptions[i]).trim().toLowerCase() == "other deductions") {
				var li = DOM.enclosingElement("li", "item", descriptions[i]);
				var inputScore = DOM.elementByClass("input", "score", li);
				inputScore.value = 0;

				var totalScore = computeTotal().total;
				inputScore.value = -totalScore;
				computeTotal();

				var comments = DOM.elementByClass("textarea", "comments", li);
				comments.value = "This student has accepted a score of 0 on the assignment due to academic misconduct.";
				comments.style.display = "block";

				$("publish").checked = true;
				if ($("posttogradesdb")) {
					$("posttogradesdb").checked = true;
				}

				return scoresheetSaveClick(event);
			}
		}
		return Events.abort(event);
	}

	function fillCriteria(operation, resetOldValue) {
		var inputs = DOM.elementsByClass("input", "score");
		for (var i = 0; i < inputs.length; i++) {
			if (inputs[i].type != "text") {
				continue;
			}
			if (inputs[i].id == "gradesdblatedaysused" ||
					DOM.hasClass(inputs[i], "latenessdeduction") ||
					DOM.hasClass(inputs[i], "otherdeductions")) {
				continue;
			}
			var newValue;
			if (operation == "max") {
				newValue = getMaxValue(inputs[i]);
				if (parseInt(inputs[i].value) && inputs[i].value > newValue) {
					// special case for extra credit (greater than "max" of 0)
					newValue = inputs[i].value;
				}
			} else if (operation == "min") {
				newValue = 0;
			} else if (operation == "clear") {
				newValue = "";
			}

			inputs[i].value = newValue;

			if (resetOldValue) {
				inputs[i].oldValue = newValue;
			}
		}

		// also clear late days used
		if (operation == "clear") {
			inputs = DOM.elementsByClass("input", "latedaysused");
			for (var i = 0; i < inputs.length; i++) {
				if (inputs[i].type == "text") {
					inputs[i].value = "";
				}
			}

			// also clear any grader comments
			var comments = DOM.elementsByClass("textarea", "comments");
			for (var i = 0; i < comments.length; i++) {
				comments[i].value = "";
			}
		}

		computeTotal();
	}

	function fillMaxClick(event) {
		fillCriteria("max");
		return Events.abort(event);
	}

	function fillMinClick(event) {
		fillCriteria("min");
		return Events.abort(event);
	}

	function getAllPreviousComments() {
		// grab any comments into cookies, put into select boxes
		var totalCommentsLength = 0;
		var commentAreas = DOM.elementsByClass("textarea", "comments");
		for (var i = 0; i < commentAreas.length; i++) {
			var name = commentAreas[i].name;
			if (!name) { continue; }
			var currentValue = commentAreas[i].value;

			var comments = getPreviousComments(name);
			if (comments.length > 0) {
				totalCommentsLength += comments.length;
				var previousCommentsArea = DOM.sibling("select", "previouscomments", commentAreas[i]);

				var commentsAdded = 0;
				var selectedIndex = -1;
				for (var j = 0; j < comments.length; j++) {
					if (true || comments[j].trim() != currentValue.trim()) {
						var option = document.createElement("option");
						option.value = comments[j].trim();
						var shortened = comments[j];
						if (shortened.length > MAX_PREVIOUS_COMMENT_LENGTH) {
							shortened = shortened.substring(0, MAX_PREVIOUS_COMMENT_LENGTH) + "...";
						}
						option.innerText = option.textContent = shortened;
						if (previousCommentsArea) {
							previousCommentsArea.appendChild(option);
						}
						commentsAdded++;

						if (comments[j].trim().substring(0, MAX_PREVIOUS_TOTAL_LENGTH) ==
							currentValue.trim().substring(0, MAX_PREVIOUS_TOTAL_LENGTH)) {
							selectedIndex = previousCommentsArea ? previousCommentsArea.length - 1 : 0;
						}
					}
				}

				if (selectedIndex >= 0 && previousCommentsArea) {
					previousCommentsArea.selectedIndex = selectedIndex;
				}

				if (commentsAdded > 0 && previousCommentsArea) {
					previousCommentsArea.style.display = "inline";
				}
			}
		}
	}

	function getMaxValue(input) {
		if (input.id == "latenesspointdeduction") {
			return 0;
		} else {
			var spans = DOM.elementsByClass("span", "max", input.parentNode);
			return (spans.length > 0) ? Number(spans[0].firstChild.nodeValue) : 0;
		}
	}

	function getMinValue(input) {
		if (input.id == "latenesspointdeduction") {
			return -99;
		} else {
			return 0;
		}
	}

	function getPreviousComments(name) {
		var cookieName = commentCookieName(name);
		var comments = [];
		// if (Cookies.exists(cookieName)) {
			// var cookieData = Cookies.get(cookieName);
		if (typeof(localStorage[cookieName]) !== "undefined") {
			// don't need to snuff out \n
			// cookieData = cookieData.replace(/\\n/g, "\n");
			comments = localStorage[cookieName].split("|!|");
		}
		return comments;
	}

	function lateDaysUsedOnFocus(event) {
		this.oldValue = this.value;
	}

	function postEarlyDaysToGradesDbClick(event) {
		$("gradesdbearlydaysearned").disabled = !$("postearlydaystogradesdb").checked;
	}

	function postLateDaysToGradesDbClick(event) {
		$("gradesdblatedaysused").disabled = !$("postlatedaystogradesdb").checked;
	}

	function previousCommentsChange(event) {
		if (!this.value) { return; }
		var commentsArea = DOM.enclosingElement("*", "commentsarea", this);
		if (!commentsArea) {
			return;
		}
		var textarea = DOM.elementByClass("textarea", "comments", commentsArea);
		if (!textarea) {
			return;
		}

		textarea.value = textarea.value.trim() + (textarea.value ? "\n" : "") + this.value;
	}

	function prevNextClick(event) {
		var changed = hasChangedDocument();
		if (changed &&
				!confirm("You have unsaved changes.\nAre you sure you want to close?")) {
			return Events.abort(event);
		}
	}

	function publishChange(event) {
		if ($("publish").checked) {
			$("publishnever").style.visibility = "visible";
		} else {
			$("publishnever").style.visibility = "hidden";
		}
	}

	function removePreviousComments(name) {
		var cookieName = commentCookieName(name);
		// if (Cookies.exists(cookieName)) {
		if (typeof(localStorage[cookieName]) !== "undefined") {
			// Cookies.remove(cookieName);
			delete localStorage[cookieName];
		}
	}

	// trimmed this way down; now it does all of its stuff in a single Ajax request
	function scoresheetSaveClick(event) {
		if ($("savepastcomments") && $("savepastcomments").checked) {
			setAllPreviousComments();
		}
		Page.clearDump();

		// make sure score sheet is completely filled out, if submitting to grades DB
		if ($("posttogradesdb") && $("posttogradesdb").checked && !scoresheetIsComplete() &&
				!confirm("Scoresheet isn't completely filled out.  Are you sure you want to submit it to the grades database?")) {
			return Events.abort(event);
		}

		if (!confirmLateness(event)) {
			return Events.abort(event);
		}

		// submit to be saved locally in grade-it application
		AjaxTools.submitForm($("scoresheetform"), "Submitting...",
			// function to run if request succeeds
			function(ajax) {
				var incomplete = !!ajax.getResponseHeader("X-GradeIt-Incomplete-Scoresheet");
				Page.dumpError("\nSaving scoresheet:\n" + ajax.responseText + "\n", incomplete);
				updateOldValues();
			}
		);

		return Events.abort(event);
	}

	function scoresheetCancelClick(event) {
		return scoresheetCloseClick(event, GradeIt.goToStudentPage);
	}

	function setAllPreviousComments() {
		// save any nonempty comments into cookies
		var totalCommentsLength = 0;
		var commentAreas = DOM.elementsByClass("textarea", "comments");
		for (var i = 0; i < commentAreas.length; i++) {
			var name = commentAreas[i].name;
			var comment = commentAreas[i].value.trim().substring(0, MAX_PREVIOUS_TOTAL_LENGTH);
			if (!name || !comment) { continue; }

			// see whether comment has been made before
			var comments = getPreviousComments(name);
			totalCommentsLength += comments.length;
			if (totalCommentsLength > MAX_TOTAL_PREVIOUS_COMMENTS) {
				continue;
			}

			var found = false;
			for (var j = 0; j < comments.length; j++) {
				if (comments[j] == comment) {
					found = true;
					break;
				}
			}

			if (!found) {
				comments.push(comment);
				comments.sort();
				setPreviousComments(name, comments);
			}
		}
	}

	function setPreviousComments(name, comments) {
		var cookieName = commentCookieName(name);
		for (var i = 0; i < comments.length; i++) {
			// don't need to snuff out \n in localStorage
			// comments[i] = comments[i].replace(/\n/g, "\\n");
		}

		// limit number of comments to reign in wordy TAs
		while (comments.length > MAX_COMMENTS_PER_CATEGORY) {
			comments.shift();
		}

		var cookieData = comments.join("|!|");
		// Cookies.remove(cookieName);
		// Cookies.set(cookieName, cookieData, 6);  // remember for 6 days
		localStorage[cookieName] = cookieData;
	}

	function showGraderNotesClick() {
		var notes = document.querySelectorAll("div.gradernote, .latedayremindernote, .commentspylink, .warningmessage");
		for (var i = 0; i < notes.length; i++) {
			if ($("showgradernotes").checked) {
				notes[i].style.display = "";
			} else {
				notes[i].style.display = "none";
			}
		}
	}

	function updateGradingTimer() {
		if (!$("gradingtimer")) {
			return;
		}
		var min = parseInt($("gradingtimer").innerHTML);
		min++;
		$("gradingtimer").innerHTML = min + " min";
	}
})();
            </script>

        
            <script type="text/javascript">
                <!-- jsfile = annotate.js -->
                var annotations;

var highlightColor = "yellow";
var MAX_PAST_ANNOTATIONS = 99;
var MAX_ANNOTATION_VISIBLE_LENGTH = 50;
var PAST_ANNOTATIONS_COOKIE_NAME = "cookie_pastannotations";
var PAST_ANNOTATIONS = [];
var SHOULD_SEND_TO_SERVER = true;   // can set to false for local testing
var STICKER_COOKIE_NAME = "cookie_stickerselect_value";

// global code
window.onunload = annotateUnload;

Events.addOnLoad(function() {
	if (!$("select")) {
		// page must have had an error
		return;
	}

	Page.loadingShow("Loading...");

	$("select").onclick = doButtonEnabling;
	$("annotate").onclick = annotateClick;
	$("highlight").onclick = highlightClick;
	$("strikeout").onclick = doButtonEnabling;
	$("sticker").onclick = doButtonEnabling;
	$("delete").onclick = doButtonEnabling;
	Page.makeLinkIntoButton($("highlightpalette"), highlightPaletteClick);
	Page.makeLinkIntoButton($("undo"), undoClick);
	Page.makeLinkIntoButton($("edit"), editClick);
	Page.makeLinkIntoButton($("clearall"), clearAllClick);
	Page.makeLinkIntoButton($("annotatecancelbutton"), GradeIt.goToStudentPage);
	Page.makeLinkIntoButton($("annotatehidebutton"), annotateHideClick);

	Events.addLinkListener($("maximizelink"), maximizeClick);

	if ($("converttabsbutton")) {
		$("converttabsbutton").onclick = convertTabsClick;
	}

	if ($("stickerselect")) {
		$("stickerselect").onchange = stickerChange;
		Cookies.makeSelectStateful($("stickerselect"), STICKER_COOKIE_NAME);
	}

	var colors = $("highlightcolors").getElementsByTagName("input");
	// discover initial highlight color (might not be yellow because they might refresh the page)
	for (var i = 0; i < colors.length; i++) {
		colors[i].onclick = highlightColorsClick;
		if (colors[i].checked) {
			var label = DOM.enclosingElement("label", "*", colors[i]);
			highlightColor = label.style.backgroundColor;
		}
	}

	var hwOverlay = $("homeworkcodeoverlay");
	hwOverlay.onmouseup = hwOverlayMouseUp;
	hwOverlay.onmouseover = doEnabling;
	hwOverlay.onclick = hwOverlayClick;
	hwOverlay.onmouseout = doEnabling;
	hwOverlay.onmousedown = doEnabling;
	hwOverlay.onmousemove = doEnabling;

	// save original code text (without markup)
	var originalCode = $("originalcode");
	var hwCode = $("homeworkcode");
	var lineNumbersArea = $("linenumbers");

	annotations = new Annotations(
		originalCode.firstChild.nodeValue,	 // non-HTML-encoded student code with no line wrapping
		hwOverlay.firstChild.nodeValue,		// non-HTML-encoded student code with line wrapping
		hwOverlay.innerHTML					   // HTML-encoded student code with line wrapping
	);
	annotations.onchange = annotationsChange;

	// fetch existing annotations from server, if any
	// (last 2 params make it do nothing on a 404 error)
	var queryParams = getQueryStringWithFilename();
	queryParams["action"] = "get";


//Page.buildUrl(Annotations.ANNOTATION_PAGE, queryParams),

	AjaxTools.fetch(
		Page.buildCoursesFileUrl(queryParams, GradeIt.ANNOTATION_XML_FILE),
		loadAnnotations,
		undefined,
		function() {
			Page.loadingHide(undefined, false);
		}
	);

	// attach hotkey listener
	document.onkeydown = bodyKeyDown;

	if ($("annotationpopuppastannotations")) {
		PAST_ANNOTATIONS = getPastAnnotations();
		if (PAST_ANNOTATIONS.length > 0) {
			for (var i = 0; i < PAST_ANNOTATIONS.length; i++) {
				var option = document.createElement("option");
				option.innerText = option.textContent = truncate(PAST_ANNOTATIONS[i], MAX_ANNOTATION_VISIBLE_LENGTH);
				option.value = PAST_ANNOTATIONS[i];
				$("annotationpopuppastannotations").appendChild(option);
			}
			// $("annotationpopuppastannotations").style.display = "inline";
		}
		$("annotationpopuppastannotations").onchange = annotationPopupSelectChange;
	}

	doEnabling();
	Page.rememberScrollPosition();
});

function addAnnotation(type, text, color, replacements, selection, sync) {
	if (!selection) {
		selection = getCodeSelection();
	}

	if (selection) {
		// don't allow highlight or strikeout of an empty range
		if (selection.start >= selection.end &&
				(type == "highlight" || type == "strikeout")) {
			return;
		}

		// display the annotation locally immediately
		var now = new Date();
		var id = now.getTime() * 1000 + now.getMilliseconds();   // semi-unique ID for each annotation
		var annotation = new Annotation(type, id, selection.start, selection.end, text, color);
		annotations.add(annotation);

		var annotatedText = annotations.getCodeTextWithAnnotations();
		// Internet Explorer sucks!
		if (Browser.isIE()) {
			annotatedText = Page.fixPreLineBreaks(annotatedText);
		}
		$("homeworkcode").innerHTML = annotatedText;

		// send to server and fix events
		annotations.attachEventHandlers();
		addOnServer(annotation, replacements, sync);
	}
}

/** Adds an annotation to the server's XML file. */
function addOnServer(annotation, replacements, sync) {
	// send the annotation to the server
	if (SHOULD_SEND_TO_SERVER) {
		if (!replacements) {
			var replacements = {};
			if (annotation.text) {
				replacements["text"] = annotation.text;
			}
			if (annotation.color) {
				replacements["color"] = annotation.color;
			}
		}

		var query = getQueryStringWithFilename(replacements);
		query["action"] = "add";
		query["type"] = annotation.type;
		query["start"] = annotation.start;
		query["end"] = annotation.end;
		query["id"] = annotation.id;
		sendAnnotationMessageToServer(query, undefined, sync);
	}
}

// called when user clicks the Annotate radio button
function annotateClick() {
	// $("highlightwhite").style.display = "inline";
	doButtonEnabling();
}

function annotateHideClick(event) {
	Events.abort(event);

	var nodesToVisit = [];
	for (var i in this.parentNode.parentNode.childNodes) {
		nodesToVisit.push(this.parentNode.parentNode.childNodes[i]);
	}
	for (var i in this.parentNode.childNodes) {
		nodesToVisit.push(this.parentNode.childNodes[i]);
	}

	for (var i in nodesToVisit) {
		var node = nodesToVisit[i];
		if (node != this && node != this.parentNode && node.style) {
			DOM.toggleDisplay(node);
		}
	}

	return Events.abort(event);
}

function annotationPopupSelectChange(event) {
	if (!this.value) { return; }
	$("annotationpopuptext").value = this.value;
}

function annotateUnload() {
	if (window && window.hwOverlay) {
		hwOverlay.onclick = undefined;
		hwOverlay.onmousedown = undefined;
		hwOverlay.onmousemove = undefined;
		hwOverlay.onmouseover = undefined;
		hwOverlay.onmouseout = undefined;
		hwOverlay.onmouseup = undefined;
	}
}

function annotationsChange(text) {
	// IE6 sucks!
	if (Browser.isIE6()) {
		text = Page.fixPreLineBreaks(text);
	}

	$("homeworkcode").innerHTML = text;
	deselect();

	annotations.attachEventHandlers();
	doButtonEnabling();
}

var eventCount = 0;
function bodyKeyDown(event) {
	event = Events.standardize(event);
	var modifier = !!(event.ctrlKey || event.altKey || event.metaKey);
	var charTyped = String.fromCharCode(event.keyCode);
	if (!charTyped) {
		charTyped = String.fromCharCode(event.charCode);
	}
	if (charTyped) {
		charTyped = charTyped.trim().toLowerCase();
	}

	// Page.dump("event #" + (++eventCount) + ": charTyped = '" + charTyped + "' (length " + charTyped.length + "), modifier = " + modifier + ", event = " + Page.getDumpText(event));

	if (modifier && (event.keyCode == Events.KEY_LEFT || event.keyCode == Events.KEY_UP)) {
		// go to previous file, if any
		var previousFileLink = document.querySelector(".previousfilelink");
		if (previousFileLink) {
			Events.simulate(previousFileLink, "click");
		}
		return Events.abort(event);
	} else if (modifier && (event.keyCode == Events.KEY_RIGHT || event.keyCode == Events.KEY_DOWN)) {
		// go to next file, if any
		var nextFileLink = document.querySelector(".nextfilelink");
		if (nextFileLink) {
			Events.simulate(nextFileLink, "click");
		}
		return Events.abort(event);
	} else if (modifier && charTyped) {
		if (charTyped == "s") {
			$("select").checked = true;
			doButtonEnabling();
			return Events.abort(event);
		} if (charTyped == "a") {
			$("annotate").checked = true;
			doButtonEnabling();
			return Events.abort(event);
		} else if (charTyped == "h") {
			$("highlight").checked = true;
			doButtonEnabling();
			return Events.abort(event);
		} else if (charTyped == "t") {
			$("strikeout").checked = true;
			doButtonEnabling();
			return Events.abort(event);
		} else if (charTyped == "k") {
			$("sticker").checked = true;
			doButtonEnabling();
			return Events.abort(event);
		} else if (charTyped == "d") {
			$("delete").checked = true;
			doButtonEnabling();
			return Events.abort(event);
		} else if (charTyped == "e") {
			editClick(event);
			return Events.abort(event);
		} else if (charTyped == "z") {
			if (!$("undo").disabled) {
				undoClick();
			}
		} else {
			var highlightColors = $("highlightcolors");
			var colorBoxes = highlightColors.querySelectorAll("input[type='radio']");
			for (var i = 0; i < colorBoxes.length; i++) {
				var box = colorBoxes[i];
				if (charTyped == "" + (i + 1)) {
					if (!$("annotate").checked) {
						$("highlight").checked = true;
					}
					box.checked = true;
					var label = DOM.enclosingElement("label", "*", box);
					highlightColor = label.style.backgroundColor;
					doButtonEnabling();
					return Events.abort(event);
				}
			}
			if (charTyped == "" + (colorBoxes.length + 1)) {
				if (!$("annotate").checked) {
					$("highlight").checked = true;
				}
				doButtonEnabling();
				highlightPaletteClick(event);
			}
		}
	}
	//} else if (modifier && charTyped == "w") {
	//	Events.abort(event);
	//	GradeIt.goToStudentPage();
	//	return Events.abort(event);
}

function clearAllClick(event) {
	Events.abort(event);
	if (confirm("Are you sure you want to delete all annotations?")) {
		annotations.clear();
		$("homeworkcode").innerHTML = annotations.getCodeTextWithAnnotations();

		// send the clearing to the server
		clearOnServer();
		doEnabling();
	}

	return Events.abort(event);
}

/** Deletes all annotations for this file from the server. */
function clearOnServer() {
	if (SHOULD_SEND_TO_SERVER) {
		var query = getQueryStringWithFilename();
		query["action"] = "clear";
		sendAnnotationMessageToServer(query);
	}
}

function convertTabsClick(event) {
	Events.abort(event);
	if (!annotations || annotations.isEmpty() ||
		confirm("Converting will mess up the indexes of your existing annotations.  " +
			"Continue?")) {
		AjaxTools.submitForm($("converttabsform"), "Converting...", AjaxTools.reloadPage);
	}
}

function deleteClick() {
	if (annotations.hasSelection()) {
		var id = annotations.selectedAnnotation.id;
		annotations.removeSelection();

		// send the removal to the server
		removeFromServer(id);
	}
}

function deselect() {
	if (window.getSelection) {
		var selection = window.getSelection();
		if (selection) {
			selection.removeAllRanges();
		}
	}
}

function editClick(event) {
	Events.abort(event);
	var editUrlSpan = DOM.child("span", "editurl", $("edit"));
	var editUrl = DOM.getText(editUrlSpan);
	window.location.href = editUrl;
	return Events.abort(event);
}

function getCodeClickedIndex() {
	var hwCode = $("homeworkcodeoverlay");
	var selection = window.getSelection();
	if (selection.rangeCount > 0 && selection.anchorNode.parentNode == hwCode) {
		// they have selected some text in the pre block
		var startIndex = selection.getRangeAt(0).startOffset;
		var endIndex = selection.getRangeAt(0).endOffset;
		if (startIndex >= 0 && endIndex >= 0 && startIndex == endIndex) {
			return startIndex;
		} else {
			return -1;
		}
	}
}

// Returns an object representing the current range of text selected in the HW overlay.
// The object's 'start' property is the 0-based starting char index within the text,
// and its 'end' property is the 0-based ending character index.
function getCodeSelection() {
	var startIndex = -1;
	var endIndex = -1;
	var hwCode = $("homeworkcodeoverlay");

	var codeText = DOM.getText(hwCode);

	if (window.getSelection || document.getSelection) {
		// non-IE (real browsers)
		if (window.getSelection) {
			var selection = window.getSelection();
		} else {
			var selection = document.getSelection();
		}

		if (selection.rangeCount == 0 || selection.anchorNode.parentNode != hwCode) {
			return null;
		}

		// BUGFIX: stupid Firefox splits text nodes into chunks of size 4096;
		// have to count these and add 4096 to our overall offset for each
		var previousCount = 0;
		var overallOffset = 0;
		var currentNode = selection.anchorNode;
		while (currentNode.previousSibling) {
			previousCount++;
			currentNode = currentNode.previousSibling;
			overallOffset += currentNode.nodeValue.length;   // should be 4096 on FF
		}

		startIndex = selection.getRangeAt(0).startOffset + overallOffset;
		endIndex = selection.getRangeAt(0).endOffset + overallOffset;

		// for block select
		var lineStart = getLineNumberOf(codeText, startIndex);
		var lineEnd = getLineNumberOf(codeText, endIndex);
		var charStart = getIndexWithinLine(codeText, startIndex);
		var charEnd = getIndexWithinLine(codeText, endIndex);

		if (GradeIt.debugMode()) {
			Page.dump("previousCount = " + previousCount + "\n" +
					"overallOffset = " + overallOffset + "\n" +
					"start/endIndex = " + startIndex + ", " + endIndex + "\n" +
					"lineStart/End = " + lineStart + ", " + lineEnd + "\n" +
					"charStart/End = " + charStart + ", " + charEnd);
		}
	} else if (document.selection && document.selection.createRange) {
		// IE6 piece of shit
		var selection = null;
		try {
			selection = document.selection.createRange();
		} catch (ex) {
			// some kind of terrible IE8 bug; morons
			// selection = document.body.createTextRange();
			return null;
		}
		startIndex = -1;  // *** TODO
		endIndex = -1;

		// obob?
		var duplicate = selection.duplicate();
		duplicate.moveToElementText(hwCode);
		duplicate.setEndPoint('EndToEnd', selection);

		// shift down by line number because IE6 sucks and uses \r\n instead of \n
		startIndex = duplicate.text.length - selection.text.length;
		endIndex = startIndex + selection.text.length;

		// for block select
		var lineStart = getLineNumberOf(codeText, startIndex);
		var lineEnd = getLineNumberOf(codeText, endIndex);
		var charStart = getIndexWithinLine(codeText, startIndex);
		var charEnd = getIndexWithinLine(codeText, endIndex);

		startIndex -= getLineNumberOf(DOM.getText(hwCode), startIndex) - 1;
		endIndex -= getLineNumberOf(DOM.getText(hwCode), endIndex) - 1;
	}

	// they have selected some text in the pre block
	if (startIndex >= 0 && endIndex >= 0 && startIndex <= endIndex) {
		return {
			start : annotations.convertIndex(startIndex, true),
			end : annotations.convertIndex(endIndex, false),

			'lineStart' : lineStart,
			'lineEnd' : lineEnd,
			'charStart' : Math.min(charStart, charEnd),
			'charEnd' : Math.max(charStart, charEnd),
			'type' : ($("blockselect").checked ? "block" : "normal")
		};
	} else {
		return null;
	}
}

function getIndexOfLine(text, lineNumber) {
	if (lineNumber == 1) {
		return 0;
	}

	var line = 1;
	for (var i = 0; i < text.length; i++) {
		if (line == lineNumber) {
			return i;
		} else if (text.charAt(i) == "\n") {
			line++;
		}
	}
	return -1;
}

// index: 0123456 78901234567
// lines: hello \nhow are you
//			  ^
//				012345
//
// index of r = 12, index of line = 7, index within line = 5
function getIndexWithinLine(text, index) {
	for (var i = 0; index - i >= 0; i++) {
		// backtrack until we have reached start of text, or start of line
		if (i == index || text.charAt(index - i - 1) == "\n") {
			return i;
		}
	}
	return -1;
}

function getLengthOfLine(text, lineNumber, index) {
	if (!index) {
		index = getIndexOfLine(text, lineNumber);
	}

	var i = 0;
	while (index + i < text.length && text.charAt(index + i) != "\n") {
		i++;
	}

	return i;
}

function getLineNumberOf(text, index) {
	var lineNumber = 1;
	for (var i = 0; i < index; i++) {
		if (text.charAt(i) == "\n") {
			lineNumber++;
		}
	}
	return lineNumber;
}

function getPastAnnotations() {
	// if (Cookies.exists(PAST_ANNOTATIONS_COOKIE_NAME)) {
	if (typeof(localStorage[PAST_ANNOTATIONS_COOKIE_NAME]) !== "undefined") {
		// var cookieData = Cookies.get(PAST_ANNOTATIONS_COOKIE_NAME);
		var cookieData = localStorage[PAST_ANNOTATIONS_COOKIE_NAME];
		// cookieData = cookieData.replace(/\\n/g, "\n");
		return cookieData.split("|!|");
	} else {
		return [];
	}
}

function getQueryStringWithFilename(replacements) {
	var queryParams = Page.getQueryString(replacements);
	if (!queryParams["filename"]) {
		var filename = Page.getQueryParameter("filename");
		if (!filename) {
			var filenameSpan = DOM.sibling("*", "filenameparam", $("homeworkcode"));
			filename = filenameSpan.innerHTML;
		}
		queryParams["filename"] = filename;
	}
	return queryParams;
}

// called when user clicks the Highlight radio button
function highlightClick() {
	// disable white highlight option
	/*$("highlightwhite").style.display = "none";
	if ($("highlightwhite").checked) {
		$("highlightwhite").checked = false;
		$("highlightyellow").checked = true;
		highlightColor = "yellow";
	}*/
	doButtonEnabling();
}

function highlightColorsClick() {
	if (!$("annotate").checked) {
		$("highlight").checked = true;
	}
	var label = DOM.enclosingElement("label", "*", this);
	highlightColor = label.style.backgroundColor;
	doButtonEnabling();
}

function highlightPaletteClick(event) {
	Events.abort(event);
	$("highlight").checked = true;
	var colors = $("highlightcolors").getElementsByTagName("input");
	for (var i = 0; i < colors.length; i++) {
		colors[i].checked = false;
	}

	TCP.popup(null, 0, function(color) {
		highlightColor = "#" + color;
		$("highlightpalette").style.backgroundColor = highlightColor;
	});
	return Events.abort(event);
}

function hwOverlayClick() {
	if ($("sticker").checked) {
		var url = $("stickerselect").value;
		if (!url) {
			url = prompt("Your sticker image's URL?");
		}
		if (!url) { return; }

		var replacements = {
			"text" : url
		};
		addAnnotation("sticker", url, undefined, replacements);
	}
}

// Called when the user lifts the mouse button on the student's code overlay.
// This initiates the adding of several kinds of annotations, such as highlights.
function hwOverlayMouseUp(event) {
	event = Events.standardize(event);

	if ($("annotate").checked || $("highlight").checked || $("strikeout").checked) {
		var type = "";
		var replacements = {};

		if ($("annotate").checked || $("highlight").checked) {
			type = "highlight";
			replacements = {
				"color" : highlightColor
			};
		} else if ($("strikeout")) {
			type = "strikeout";
		}

		var selection = getCodeSelection();
		if (!selection) {
			return;
		}

		if (selection.type == "block" && selection.charStart < selection.charEnd) {
			// Page.dump(selection);
			var hwCode = $("homeworkcodeoverlay");
			var codeText = DOM.getText(hwCode);

			for (var line = selection.lineStart; line <= selection.lineEnd; line++) {
				var lineIndex = getIndexOfLine(codeText, line);
				var lineLength = getLengthOfLine(codeText, line, lineIndex);

				// only add the annotations to lines that are long enough
				if (lineLength > 0) {
					var newSelection = {
						start : lineIndex + selection.charStart,
						end : lineIndex + Math.min(lineLength, selection.charEnd)
					};

					// BUGFIX: synchronous mode to make sure they all get added without collision
					addAnnotation(type, undefined, highlightColor, replacements, newSelection, true);
				}
			}
		} else {
			addAnnotation(type, undefined, highlightColor, replacements);
		}
	} else if ($("delete").checked) {
		var selection = getCodeSelection();
		if (selection) {
			annotations.removeAllInRange(selection.start, selection.end);
		}
	}

	if ($("annotate").checked) {
		// prompt for their annotation text message

		if ($("annotationpopup").style.display != "block") {
			$("annotationpopuptext").value = "";
			$("annotationpopup").style.backgroundColor = highlightColor;
			$("annotationpopup").style.bottom = "";
			$("annotationpopup").style.right = "";
			$("annotationpopup").style.left = event.pageX + "px";
			$("annotationpopup").style.top = event.pageY + "px";
			$("annotationpopup").style.display = "block";

			// bound to bottom/right corners if too far right/down
			if (parseInt($("annotationpopup").style.left) + $("annotationpopup").offsetWidth >= document.body.offsetWidth) {
				$("annotationpopup").style.left = "";
				$("annotationpopup").style.right = "0px";
			}
			if (parseInt($("annotationpopup").style.top) + $("annotationpopup").offsetHeight >=
					document.body.offsetHeight) {  // - Math.max(60, $("annotationpopup").offsetHeight)) {

				if (false || document.body.offsetHeight >= screen.availHeight) {
					// scrollbar, tall document
					$("annotationpopup").style.top = "";
					$("annotationpopup").style.bottom = "10px";
				} else {
					// no scrollbar, taller browser window
					$("annotationpopup").style.top = (document.body.offsetHeight - $("annotationpopup").offsetHeight) + "px";
				}
			}
			$("annotationpopuptext").focus();

			// set up handler for when they are done typing the annotation
			var closeDialog = function() {
				$("annotationpopup").style.display = "none";

				var text = $("annotationpopuptext").value.trim();
				if (!text) { return; }
				$("annotationpopuptext").value = "";

				if (!Arrays.contains(PAST_ANNOTATIONS, text)) {
					PAST_ANNOTATIONS.push(text);
					// PAST_ANNOTATIONS.sort();

					var option = document.createElement("option");
					option.innerText = option.textContent = truncate(text, MAX_ANNOTATION_VISIBLE_LENGTH);
					option.value = text;
					$("annotationpopuppastannotations").appendChild(option);
					setPastAnnotations(PAST_ANNOTATIONS);
					// $("annotationpopuppastannotations").style.display = "inline";
				}

				var replacements = {
					"text" : text,
					"color" : highlightColor
				};
				addAnnotation("annotation", text, highlightColor, replacements, selection);
			};

			var cancelDialog = function() {
				$("annotationpopuptext").value = "";
				closeDialog();
			};

			$("annotationpopupok").onclick = closeDialog;
			$("annotationpopupcancel").onclick = cancelDialog;

			var closeDialogKeyDown = function(keyevent) {
				keyevent = Events.standardize(keyevent);
				var key = keyevent.keyCode || keyevent.which;
				if (key == 13) {  // user pressed Enter
					closeDialog();
				} else if (key == 27) {  // Esc
					cancelDialog();
				}
			}

			$("annotationpopup").onkeydown = closeDialogKeyDown;
			$("annotationpopuptext").onkeydown = closeDialogKeyDown;
			$("annotationpopuppastannotations").onkeydown = closeDialogKeyDown;
		}

		/*
		var text = prompt("Your annotation text?");
		if (!text) { return; }
		var replacements = {
			"text" : text,
			"color" : highlightColor
		};
		addAnnotation("annotation", text, highlightColor, replacements, selection);
		*/
	}
}

// previous annotations exist; parse and display them
function loadAnnotations(ajax) {
	annotations.loadFromXml(ajax);
	annotations.attachEventHandlers();
	Page.loadingHide(undefined, false);
	doEnabling();
}

function maximizeClick(event) {
	if (!Frames.checkLoading(event)) {
		return false;
	}

	if (window.parent && window.parent.frames &&
			window.parent.frames["scoresheetframe"]) {
		// check whether scoresheet has changed in multipane view
		var changed = hasChanged(window.parent.frames["scoresheetframe"].document);
		if (changed && !confirm("You have unsaved scoresheet changes.\n" +
				"Are you sure you want to leave this page?")) {
			return Events.abort(event);
		}
	}

	return true;
}

/** Sends an annotation's new text to the server. */
function modifyOnServer(id, text, index) {
	if (SHOULD_SEND_TO_SERVER) {
		var query = getQueryStringWithFilename();
		query["action"] = "modify";
		query["id"] = id;
		query["text"] = text;
		if (typeof(index) !== "undefined") {
			query["index"] = index;
		}
		sendAnnotationMessageToServer(query);
	}

	// doEnabling();
}

function setPastAnnotations(annotations) {
	for (var i = 0; i < annotations.length; i++) {
		annotations[i] = annotations[i].replace(/\n/g, "\\n");
	}

	// limit number of comments to reign in wordy TAs
	while (annotations.length > MAX_PAST_ANNOTATIONS) {
		annotations.shift();
	}

	var cookieData = annotations.join("|!|");
	// Cookies.set(PAST_ANNOTATIONS_COOKIE_NAME, cookieData, 2);  // remember for 2 days
	localStorage[PAST_ANNOTATIONS_COOKIE_NAME] = cookieData;
}

function stickerChange() {
	$("sticker").checked = true;
}

function truncate(str, len) {
	if (str.length > len) {
		str = str.substring(0, len) + " ...";
	}
	return str;
}

function undoClick(event) {
	Events.abort(event);
	$("undo").disabled = true;
	annotations.undo();

	// need to tell the server
	undoOnServer();

	// fetch existing annotations from server, if any
	// (last 2 params make it do nothing on a 404 error)
	var queryParams = getQueryStringWithFilename();
	queryParams["action"] = "get";

	AjaxTools.fetch(
		Page.buildCoursesFileUrl(queryParams, GradeIt.ANNOTATION_XML_FILE),
		function(ajax) {
			annotations.clean();
			loadAnnotations(ajax);
		},
		undefined,
		function() {
			Page.loadingHide(undefined, false);
		}
	);

	return Events.abort(event);
}

function undoOnServer() {
	Page.loadingShow("Undoing...");
	var query = getQueryStringWithFilename();
	query["action"] = "undo";
	sendAnnotationMessageToServer(query, function() {
		doButtonEnabling();
	});
}
            </script>

        
    </head>

    
        <body data-gr-c-s-loaded="true">
        <div class="filearea">

        
<h1>
            CSE             143            Assignment 4 (EvilHangman)            Score Sheet
        </h1>


<form id="scoresheetform" action="https://gradeit.cs.washington.edu/uwcse/scoresheet/143/19au/DC/juntiw3/a4/scoresheet_save.php" method="post" enctype="application/xml" autocomplete="off">
    <table>
        <tbody><tr>
            <td>
                <h2>Student(s):</h2>
            </td>
            <td>

                                                    <input type="text" class="studentinfo" name="student_name" size="48" readonly="readonly" style="border: 0;" title="Submission " value="juntiw3 &lt;juntiw3@uw.edu&gt;">

                        <br>

                    </td>
        </tr>

                        <tr>
                <td>
                    <h2>Graded by:</h2>
                </td>
                <td>
                                                    <input name="grader" type="text" class="studentinfo grader" size="48" readonly="readonly" style="border: 0;" value="Anthony Tran &lt;trananth@uw.edu&gt;">
                                            </td>
        </tr>
    </tbody></table>

            <div class="uniqueid" style="font-size: small; float: right">:.:::.::.:::.:.::::.:::..:::..:</div>
    
    <ul id="overalllist">
        <li id="2442" class="category total">
            <span class="categorytotal">19</span>
            <span class="slash"> / </span>
            <span class="max categorymax">20</span> : <span class="categoryname">Total Score</span>

            <ul id="2443" class="category">

                
<li class="category" id="2444">
                    <span class="categorytotal">13</span><span class="slash"> / </span><span class="max categorymax">13</span> :
        
        <span class="categoryname">External Correctness</span>

    <ul id="2444" class="category">

            
<li class="category" id="2445">
                    <span class="categorytotal">2</span><span class="slash"> / </span><span class="max categorymax">2</span> :
        
        <span class="categoryname">fields and getters</span>

    <ul id="2445" class="category">

            


<li class="item" id="2446"><input name="score_criteria|External+Correctness|fields+and+getters|has+at+least+one+field%2Fgetter+pair" class="score" value="1" type="text" size="1" maxlength="4" readonly="readonly" style="border: 0;"> <input name="id_criteria|External+Correctness|fields+and+getters|has+at+least+one+field%2Fgetter+pair" type="hidden" value="0">

        
                    / <span class="max itemmax">1</span> :
        
        
        <span class="description">has at least one field/getter pair</span><br>

        
        <span class="comments" style="display: none;"></span>

        
    </li>




<li class="item" id="2447"><input name="score_criteria|External+Correctness|fields+and+getters|has+all+3+field%2Fgetter+pairs" class="score" value="1" type="text" size="1" maxlength="4" readonly="readonly" style="border: 0;"> <input name="id_criteria|External+Correctness|fields+and+getters|has+all+3+field%2Fgetter+pairs" type="hidden" value="1">

        
                    / <span class="max itemmax">1</span> :
        
        
        <span class="description">has all 3 field/getter pairs</span><br>

        
        <span class="comments" style="display: none;"></span>

        
    </li>


        </ul>

    
</li><li class="category" id="2448">
                    <span class="categorytotal">4</span><span class="slash"> / </span><span class="max categorymax">4</span> :
        
        <span class="categoryname">constructor</span>

    <ul id="2448" class="category">

            


<li class="item" id="2449"><input name="score_criteria|External+Correctness|constructor|word+set+is+initialized+properly" class="score" value="2" type="text" size="1" maxlength="4" readonly="readonly" style="border: 0;"> <input name="id_criteria|External+Correctness|constructor|word+set+is+initialized+properly" type="hidden" value="2">

        
                    / <span class="max itemmax">2</span> :
        
        
        <span class="description">word set is initialized properly</span><br>

        
        <span class="comments" style="display: none;"></span>

        
    </li>




<li class="item" id="2450"><input name="score_criteria|External+Correctness|constructor|pattern+has+exactly+length+number+of+dashes" class="score" value="1" type="text" size="1" maxlength="4" readonly="readonly" style="border: 0;"> <input name="id_criteria|External+Correctness|constructor|pattern+has+exactly+length+number+of+dashes" type="hidden" value="3">

        
                    / <span class="max itemmax">1</span> :
        
        
        <span class="description">pattern has exactly length number of dashes</span><br>

        
        <span class="comments" style="display: none;"></span>

        
    </li>




<li class="item" id="2451"><input name="score_criteria|External+Correctness|constructor|pattern+correct%2C+guesses+and+guessesLeft+correct" class="score" value="1" type="text" size="1" maxlength="4" readonly="readonly" style="border: 0;"> <input name="id_criteria|External+Correctness|constructor|pattern+correct%2C+guesses+and+guessesLeft+correct" type="hidden" value="4">

        
                    / <span class="max itemmax">1</span> :
        
        
        <span class="description">pattern correct, guesses and guessesLeft correct</span><br>

        
        <span class="comments" style="display: none;"></span>

        
    </li>


        </ul>

    
</li><li class="category" id="2452">
                    <span class="categorytotal">7</span><span class="slash"> / </span><span class="max categorymax">7</span> :
        
        <span class="categoryname">record</span>

    <ul id="2452" class="category">

            
<li class="category" id="2453">
                    <span class="categorytotal">3</span><span class="slash"> / </span><span class="max categorymax">3</span> :
        
        <span class="categoryname">dictionary2.txt logs</span>

    <ul id="2453" class="category">

            


<li class="item" id="2454"><input name="score_criteria|External+Correctness|record|dictionary2_txt+logs|record+works+for+log1" class="score" value="1" type="text" size="1" maxlength="4" readonly="readonly" style="border: 0;"> <input name="id_criteria|External+Correctness|record|dictionary2_txt+logs|record+works+for+log1" type="hidden" value="5">

        
                    / <span class="max itemmax">1</span> :
        
        
        <span class="description">record works for log1</span><br>

        
        <span class="comments" style="display: none;"></span>

        
    </li>




<li class="item" id="2455"><input name="score_criteria|External+Correctness|record|dictionary2_txt+logs|record+works+for+log2" class="score" value="1" type="text" size="1" maxlength="4" readonly="readonly" style="border: 0;"> <input name="id_criteria|External+Correctness|record|dictionary2_txt+logs|record+works+for+log2" type="hidden" value="6">

        
                    / <span class="max itemmax">1</span> :
        
        
        <span class="description">record works for log2</span><br>

        
        <span class="comments" style="display: none;"></span>

        
    </li>




<li class="item" id="2456"><input name="score_criteria|External+Correctness|record|dictionary2_txt+logs|record+works+for+log3" class="score" value="1" type="text" size="1" maxlength="4" readonly="readonly" style="border: 0;"> <input name="id_criteria|External+Correctness|record|dictionary2_txt+logs|record+works+for+log3" type="hidden" value="7">

        
                    / <span class="max itemmax">1</span> :
        
        
        <span class="description">record works for log3</span><br>

        
        <span class="comments" style="display: none;"></span>

        
    </li>


        </ul>

    
</li><li class="category" id="2457">
                    <span class="categorytotal">4</span><span class="slash"> / </span><span class="max categorymax">4</span> :
        
        <span class="categoryname">dictionary.txt (large dictionary) logs</span>

    <ul id="2457" class="category">

            


<li class="item" id="2458"><input name="score_criteria|External+Correctness|record|dictionary_txt+%28large+dictionary%29+logs|record+words+for+at+least+one+log" class="score" value="1" type="text" size="1" maxlength="4" readonly="readonly" style="border: 0;"> <input name="id_criteria|External+Correctness|record|dictionary_txt+%28large+dictionary%29+logs|record+words+for+at+least+one+log" type="hidden" value="8">

        
                    / <span class="max itemmax">1</span> :
        
        
        <span class="description">record words for at least one log</span><br>

        
        <span class="comments" style="display: none;"></span>

        
    </li>




<li class="item" id="2459"><input name="score_criteria|External+Correctness|record|dictionary_txt+%28large+dictionary%29+logs|record+works+for+two+logs" class="score" value="1" type="text" size="1" maxlength="4" readonly="readonly" style="border: 0;"> <input name="id_criteria|External+Correctness|record|dictionary_txt+%28large+dictionary%29+logs|record+works+for+two+logs" type="hidden" value="9">

        
                    / <span class="max itemmax">1</span> :
        
        
        <span class="description">record works for two logs</span><br>

        
        <span class="comments" style="display: none;"></span>

        
    </li>




<li class="item" id="2460"><input name="score_criteria|External+Correctness|record|dictionary_txt+%28large+dictionary%29+logs|record+works+for+most+logs" class="score" value="1" type="text" size="1" maxlength="4" readonly="readonly" style="border: 0;"> <input name="id_criteria|External+Correctness|record|dictionary_txt+%28large+dictionary%29+logs|record+works+for+most+logs" type="hidden" value="10">

        
                    / <span class="max itemmax">1</span> :
        
        
        <span class="description">record works for most logs</span><br>

        
        <span class="comments" style="display: none;"></span>

        
    </li>




<li class="item" id="2461"><input name="score_criteria|External+Correctness|record|dictionary_txt+%28large+dictionary%29+logs|all+correct+-+record+works+for+all+logs" class="score" value="1" type="text" size="1" maxlength="4" readonly="readonly" style="border: 0;"> <input name="id_criteria|External+Correctness|record|dictionary_txt+%28large+dictionary%29+logs|all+correct+-+record+works+for+all+logs" type="hidden" value="11">

        
                    / <span class="max itemmax">1</span> :
        
        
        <span class="description">all correct - record works for all logs</span><br>

        
        <span class="comments" style="display: none;"></span>

        
    </li>


        </ul>

    
        </li></ul>

    
        </li></ul>

    
</li><li class="category" id="2462">
                    <span class="categorytotal">6</span><span class="slash"> / </span><span class="max categorymax">7</span> :
        
        <span class="categoryname">Internal Correctness and Style</span>

    <ul id="2462" class="category">

            


<li class="item" id="2463"><input name="score_criteria|Internal+Correctness+and+Style|throws+all+exceptions" class="score" value="1" type="text" size="1" maxlength="4" readonly="readonly" style="border: 0;"> <input name="id_criteria|Internal+Correctness+and+Style|throws+all+exceptions" type="hidden" value="12">

        
                    / <span class="max itemmax">1</span> :
        
        
        <span class="description">throws all exceptions</span><br>

        
        <span class="comments" style="display: none;"></span>

        
    </li>


<li class="category" id="2464">
                    <span class="categorytotal">2</span><span class="slash"> / </span><span class="max categorymax">2</span> :
        
        <span class="categoryname">Method Decomposition</span>

    <ul id="2464" class="category">

            


<li class="item" id="2465"><input name="score_criteria|Internal+Correctness+and+Style|Method+Decomposition|attempt" class="score" value="1" type="text" size="1" maxlength="4" readonly="readonly" style="border: 0;"> <input name="id_criteria|Internal+Correctness+and+Style|Method+Decomposition|attempt" type="hidden" value="13">

        
                    / <span class="max itemmax">1</span> :
        
        
        <span class="description">attempt</span><br>

        
        <span class="comments" style="display: none;"></span>

        
    </li>




<li class="item" id="2466"><input name="score_criteria|Internal+Correctness+and+Style|Method+Decomposition|correct" class="score" value="1" type="text" size="1" maxlength="4" readonly="readonly" style="border: 0;"> <input name="id_criteria|Internal+Correctness+and+Style|Method+Decomposition|correct" type="hidden" value="14">

        
                    / <span class="max itemmax">1</span> :
        
        
        <span class="description">correct</span><br>

        
        <span class="comments" style="display: none;"></span>

        
    </li>


        </ul>

    
</li><li class="category" id="2467">
                    <span class="categorytotal">2</span><span class="slash"> / </span><span class="max categorymax">2</span> :
        
        <span class="categoryname">Comments</span>

    <ul id="2467" class="category">

            


<li class="item" id="2468"><input name="score_criteria|Internal+Correctness+and+Style|Comments|attempt+comments" class="score" value="1" type="text" size="1" maxlength="4" readonly="readonly" style="border: 0;"> <input name="id_criteria|Internal+Correctness+and+Style|Comments|attempt+comments" type="hidden" value="15">

        
                    / <span class="max itemmax">1</span> :
        
        
        <span class="description">attempt comments</span><br>

        
        <span class="comments" style="display: none;"></span>

        
    </li>




<li class="item" id="2469"><input name="score_criteria|Internal+Correctness+and+Style|Comments|correct+comments" class="score" value="1" type="text" size="1" maxlength="4" readonly="readonly" style="border: 0;"> <input name="id_criteria|Internal+Correctness+and+Style|Comments|correct+comments" type="hidden" value="16">

        
                    / <span class="max itemmax">1</span> :
        
        
        <span class="description">correct comments</span><br>

        
        <span class="comments" style="display: none;"></span>

        
    </li>


        </ul>

    


</li><li class="item" id="2470"><input name="score_criteria|Internal+Correctness+and+Style|Otherwise+Good+Style" class="score" value="1" type="text" size="1" maxlength="4" readonly="readonly" style="border: 0;"> <input name="id_criteria|Internal+Correctness+and+Style|Otherwise+Good+Style" type="hidden" value="17">

        
                    / <span class="max itemmax">2</span> :
        
        
        <span class="description">Otherwise Good Style</span><br>

        
        <span class="comments">-1: see yellow</span>

        
    </li>


        </ul>

    
</li><li class="category" id="2471">
                    <span class="categorytotal"></span><span class="slash" style="display: none"> / </span><span class="max categorymax zeromax" style="display: none">0</span><span class="colon" style="visibility: hidden"> : </span>
        
        <span class="categoryname">Lateness and Other Deductions</span>

    <ul id="2471" class="category">

            
<li><span class="zeromax"> <input type="text" size="1" class="zeromax" readonly="readonly" style="border: 0;"> <span class="zeromax" style="visibility: hidden">/ 0 :</span>
</span>

            
            <input name="due" class="duetime" value="Thu 2019/10/24 11:30pm" type="text" size="30" readonly="readonly" tabindex="-1" style="border: 0;"> Due</li>


<li><span class="zeromax"> <input type="text" size="1" class="zeromax" readonly="readonly" style="border: 0;"> <span class="zeromax" style="visibility: hidden">/ 0 :</span>
</span>

            
            <input name="submitted" class="duetime" value="Thu 2019/10/24 03:36pm" type="text" size="30" readonly="readonly" tabindex="-1" style="border: 0;">
             Submitted
             (on time)        </li>


<li class="latenessitem"><input name="latedaysused" class="latedaysused" type="text" size="1" maxlength="2" value="0" readonly="readonly" style="border: 0;"> <span class="zeromax" style="visibility: hidden"> / 0 : </span>

            
            Late days used on this assignment

            
            
                    </li>




<li class="item" id="2472"><input name="score_criteria|Lateness+and+Other+Deductions|Lateness+deduction" class="score latenessdeduction" value="0" type="text" size="1" maxlength="4" readonly="readonly" style="border: 0;"> <input name="id_criteria|Lateness+and+Other+Deductions|Lateness+deduction" type="hidden" value="-1">

                    <span class="itemmin" style="display: none">-999</span>
        
                    <span class="zeromax" style="visibility: hidden">/ </span><span class="max itemmax zeromax" style="visibility: hidden">0</span><span class="zeromax"> : </span>
        
        
        <span class="description">Lateness deduction</span><br>

        
        <span class="comments" style="display: none;"></span>

        
    </li>




<li class="item" id="2473"><input name="score_criteria|Lateness+and+Other+Deductions|Other+deductions" class="score otherdeductions" value="" type="text" size="1" maxlength="4" readonly="readonly" style="border: 0;"> <input name="id_criteria|Lateness+and+Other+Deductions|Other+deductions" type="hidden" value="-1">

                    <span class="itemmin" style="display: none">-999</span>
        
                    <span class="zeromax" style="visibility: hidden">/ </span><span class="max itemmax zeromax" style="visibility: hidden">0</span><span class="zeromax"> : </span>
        
        
        <span class="description">Other deductions</span><br>

        
        <span class="comments" style="display: none;"></span>

        
    </li>


        </ul>

                </li></ul>
        </li>

        <li id="2474" class="overallcommentsarea">
            <legend>Overall comments:</legend>
            
        <span class="comments">Great job Terry!</span>

                </li>

                

        <form id="backread-email" method="POST" action="https://gradeit.cs.washington.edu/uwcse/ajax/submission/backread-request/" style="display: none;">
        <input type="hidden" name="course" value="143">
        <input type="hidden" name="quarter" value="19au">
        <input type="hidden" name="assignment" value="a4">
        <input type="hidden" name="section" value="DC">
        <input type="hidden" name="student" value="juntiw3">
        <!-- filled in at email-call time: -->
        <input type="hidden" name="backreadcomments" value="backreadcomment placeholder">
    </form>

    
    </ul></form></div>

            <div class="filearea">
                


<h1>Annotations:

            
                HangmanManager.java

            
        </h1>


        
<table class="annotationtable">
    <tbody><tr>
        <td></td>
        <td>
<pre class="characternumbers">        10        20        30        40        50        60        70        80        90       100       110       120</pre>
                </td>
    </tr>

    <tr>
        <td>
<pre class="linenumbers" id="linenumbers"><span id="line1">  1</span>
<span id="line2">  2</span>
<span id="line3">  3</span>
<span id="line4">  4</span>
<span id="line5">  5</span>
<span id="line6">  6</span>
<span id="line7">  7</span>
<span id="line8">  8</span>
<span id="line9">  9</span>
<span id="line10"> 10</span>
<span id="line11"> 11</span>
<span id="line12"> 12</span>
<span id="line13"> 13</span>
<span id="line14"> 14</span>
<span id="line15"> 15</span>
<span id="line16"> 16</span>
<span id="line17"> 17</span>
<span id="line18"> 18</span>
<span id="line19"> 19</span>
<span id="line20"> 20</span>
<span id="line21"> 21</span>
<span id="line22"> 22</span>
<span id="line23"> 23</span>
<span id="line24"> 24</span>
<span id="line25"> 25</span>
<span id="line26"> 26</span>
<span id="line27"> 27</span>
<span id="line28"> 28</span>
<span id="line29"> 29</span>
<span id="line30"> 30</span>
<span id="line31"> 31</span>
<span id="line32"> 32</span>
<span id="line33"> 33</span>
<span id="line34"> 34</span>
<span id="line35"> 35</span>
<span id="line36"> 36</span>
<span id="line37"> 37</span>
<span id="line38"> 38</span>
<span id="line39"> 39</span>
<span id="line40"> 40</span>
<span id="line41"> 41</span>
<span id="line42"> 42</span>
<span id="line43"> 43</span>
<span id="line44"> 44</span>
<span id="line45"> 45</span>
<span id="line46"> 46</span>
<span id="line47"> 47</span>
<span id="line48"> 48</span>
<span id="line49"> 49</span>
<span id="line50"> 50</span>
<span id="line51"> 51</span>
<span id="line52"> 52</span>
<span id="line53"> 53</span>
<span id="line54"> 54</span>
<span id="line55"> 55</span>
<span id="line56"> 56</span>
<span id="line57"> 57</span>
<span id="line58"> 58</span>
<span id="line59"> 59</span>
<span id="line60"> 60</span>
<span id="line61"> 61</span>
<span id="line62"> 62</span>
<span id="line63"> 63</span>
<span id="line64"> 64</span>
<span id="line65"> 65</span>
<span id="line66"> 66</span>
<span id="line67"> 67</span>
<span id="line68"> 68</span>
<span id="line69"> 69</span>
<span id="line70"> 70</span>
<span id="line71"> 71</span>
<span id="line72"> 72</span>
<span id="line73"> 73</span>
<span id="line74"> 74</span>
<span id="line75"> 75</span>
<span id="line76"> 76</span>
<span id="line77"> 77</span>
<span id="line78"> 78</span>
<span id="line79"> 79</span>
<span id="line80"> 80</span>
<span id="line81"> 81</span>
<span id="line82"> 82</span>
<span id="line83"> 83</span>
<span id="line84"> 84</span>
<span id="line85"> 85</span>
<span id="line86"> 86</span>
<span id="line87"> 87</span>
<span id="line88"> 88</span>
<span id="line89"> 89</span>
<span id="line90"> 90</span>
<span id="line91"> 91</span>
<span id="line92"> 92</span>
<span id="line93"> 93</span>
<span id="line94"> 94</span>
<span id="line95"> 95</span>
<span id="line96"> 96</span>
<span id="line97"> 97</span>
<span id="line98"> 98</span>
<span id="line99"> 99</span>
<span id="line100">100</span>
<span id="line101">101</span>
<span id="line102">102</span>
<span id="line103">103</span>
<span id="line104">104</span>
<span id="line105">105</span>
<span id="line106">106</span>
<span id="line107">107</span>
<span id="line108">108</span>
<span id="line109">109</span>
<span id="line110">110</span>
<span id="line111">111</span>
<span id="line112">112</span>
<span id="line113">113</span>
<span id="line114">114</span>
<span id="line115">115</span>
<span id="line116">116</span>
<span id="line117">117</span>
<span id="line118">118</span>
<span id="line119">119</span>
<span id="line120">120</span>
<span id="line121">121</span>
<span id="line122">122</span>
<span id="line123">123</span>
<span id="line124">124</span>
<span id="line125">125</span>
<span id="line126">126</span>
<span id="line127">127</span>
<span id="line128">128</span>
<span id="line129">129</span>
<span id="line130">130</span>
<span id="line131">131</span>
<span id="line132">132</span>
<span id="line133">133</span>
<span id="line134">134</span>
<span id="line135">135</span>
<span id="line136">136</span>
<span id="line137">137</span>
<span id="line138">138</span>
<span id="line139">139</span>
<span id="line140">140</span>
<span id="line141">141</span>
<span id="line142">142</span>
<span id="line143">143</span>
<span id="line144">144</span>
<span id="line145">145</span>
<span id="line146">146</span>
<span id="line147">147</span>
<span id="line148">148</span>
<span id="line149">149</span>
<span id="line150">150</span>
<span id="line151">151</span>
<span id="line152">152</span>
<span id="line153">153</span>
<span id="line154">154</span>
<span id="line155">155</span>
<span id="line156">156</span>
<span id="line157">157</span>
<span id="line158">158</span>
<span id="line159">159</span>
<span id="line160">160</span>
<span id="line161">161</span>
<span id="line162">162</span>
<span id="line163">163</span>
<span id="line164">164</span>
<span id="line165">165</span>
<span id="line166">166</span>
<span id="line167">167</span>
<span id="line168">168</span>
<span id="line169">169</span>
<span id="line170">170</span>
<span id="line171">171</span>
<span id="line172">172</span>
<span id="line173">173</span>
<span id="line174">174</span>
<span id="line175">175</span>
<span id="line176">176</span>
<span id="line177">177</span>
<span id="line178">178</span>
<span id="line179">179</span>
<span id="line180">180</span>
<span id="line181">181</span>
<span id="line182">182</span>
<span id="line183">183</span>
<span id="line184">184</span>
<span id="line185">185</span>
</pre>
                </td>

        <td class="tablecodecell">
            <div id="annotationcodearea" class="annotationcodearea">
                <pre id="homeworkcode" class="homeworkcode" style="color: transparent; padding-right: 19em;">import java.util.Collection;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;

//October 19, 2019
//Terry Wang
//CSE 143 Homework 4:EvilHangman
//Class Introduction:
//This class creates a HangmanManager object and some methods that
//manage the functions of a evil hangman game.

public class HangmanManager {
   private String pattern;
   private int remainingCounts;
   <span id="1572137149160160" class="highlight" style="background-color: rgb(255, 255, 51);"><span id="1572137203233233" class="annotation" style="background-color: rgb(255, 255, 51); right: 0px; float: right; font-family: sans-serif;">-1: This is an unnecessary field. In the constructor, once you have added all of the words of wordLength to the dictionary, you can assume that you are only working with words of wordLength so you do not have to store this as a field.</span>private int wordLength;</span>
   private Set&lt;String&gt; possibleWords;
   private Set&lt;Character&gt; guessedLetters;
   
   //Pre: Receives a dictionary, length of word and the max attempts of guessing
   //    Throw a IllegalArgumentException if input word length &lt; 1 or max attempts &lt; 0
   //Post: Put all the words in the dictionary that match wtih the input length in a set (Eliminating duplicate)
   //    Initialize the game display as "- - - -" which '-' stands for unrevealed characters
   public HangmanManager(Collection&lt;String&gt; dictionary, int length, int max) {
      if (length &lt; 1 || max &lt; 0) {
         throw new IllegalArgumentException();
      }
      pattern = "-";
      wordLength = length;
      remainingCounts = max;
      possibleWords = new TreeSet&lt;String&gt;();
      guessedLetters = new TreeSet&lt;Character&gt;();
      
      for (String word : dictionary) {
         if (word.length() == wordLength) {
            possibleWords.add(word);
         }
      }
      for (int i = 1; i &lt; length; i++) {
         pattern += " -";
      }
      
   }
   
   //Returns the current possible set for wor<span id="1572492119636636" class="sticker"><img class="stickerimage" style="float: right;" src="./Grade-It - Score Report_ 143 19au a4 DC JUNTIW3_files/happyDogIsHappy.png" alt="sticker: happyDogIsHappy.png"></span>ds choices
   public Set&lt;String&gt; words() {
      return possibleWords;
   }
   
   //Returns the remaining attempts of guessing
   public int guessesLeft() {
      return remainingCounts;
   }
   
   //Returns a set which contains all the words that have been guessed
   public Set&lt;Character&gt; guesses() {
      return guessedLetters;
   }
   
   //Pre: Throw a IllegalStateException if the current possible words set is empty
   //Post: Returns the current game pattern
   public String pattern() {
      if (possibleWords.isEmpty() ) {
         throw new IllegalStateException();
      }
      return pattern;
      
   }
   //Pre: Receives user's guess (Assume all input character are lower-cased)
   //    Throw a IllegalStateException if attempts left is less than 1 or if the set of possible words is empty.
   //    Otherwise, throw a IllegalArgumentException if the input character was already guessed before.
   //Post:
   // Update the game pattern (Refers to private helper methods' comments)
   // (If guessed word occurs in pattern, update the displayed pattern from "- - - -" to "a - - n" (For example) )
   // Returns the occurences of input character in updated game pattern.
   // (If input character has no occurence in pattern, deduct 1 from remaining attempts)
   public int record(char guess) {
      
      Map&lt;String, Integer&gt; patternOccurences = new TreeMap&lt;String, Integer&gt;();
      Map&lt;String, Set&lt;String&gt;&gt; patternWords = new TreeMap&lt;String, Set&lt;String&gt;&gt;();
      Set&lt;String&gt; currentPossiblewords = new TreeSet&lt;String&gt;();
      int occurences = 0;
      
      inputCheck(guess);
      guessedLetters.add(guess);
      
      updatePattern(currentPossiblewords, patternOccurences, patternWords, guess);
      
      occurences = retrieveTheLargest(currentPossiblewords, patternOccurences, patternWords, guess);
      
      if (occurences == 0)
         remainingCounts--;
      
      return occurences;
   }
   
   //Private Helper Method
   //Pre: Receive a set of current possible word choices, the input guess,
   //    a map of pattern corresponds with the occurences of input guess
   //    and a map of pattern corresponds with possible words choices
   //Post: Based on the input guess, store all possible new game patterns and occurences of guessed chracters in those patterns
   private void updatePattern(Set&lt;String&gt; currentPossiblewords, Map&lt;String, Integer&gt; patternOccurences,
   Map&lt;String, Set&lt;String&gt;&gt; patternWords, char guess) {
      String newPattern = "";
      int occurences;
      
      for (String word : possibleWords)// goes through all the words in the current set
      {
         newPattern = pattern;
         occurences = 0;
         for (int i = 0; i &lt; wordLength; i++)// goes through each word
         {
            if (guess == word.charAt(i)) {
               occurences++;
               newPattern = newPattern.substring(0, 2 * i) + guess + newPattern.substring(2 * i + 1);
               
            }
         }
     
         if (!patternWords.containsKey(newPattern)) {
            Set&lt;String&gt; temp = new TreeSet&lt;String&gt;();
            temp.add(word);
            patternWords.put(newPattern, temp);
            patternOccurences.put(newPattern, occurences);
            
         } else {
            currentPossiblewords = patternWords.get(newPattern);
            currentPossiblewords.add(word);
         }
      }
      currentPossiblewords = new TreeSet&lt;String&gt;();
   }
   
   //Private Helper Method
   //Pre: Receive a set of current possible word choices, the input guess,
   //    a map of pattern corresponds with the occurences of input guess
   //    and a map of pattern corresponds with possible words choices
   //Post: Returns the occurences of guess from the pattern which contains the most occurences of guess
   //    (If a tie happened in words families, choose the one appeared earlier, 'A...' is prior to 'B....'
   //    Set this resulting pattern and possible words set after as the current game set.
   private int retrieveTheLargest(Set&lt;String&gt; currentPossiblewords, Map&lt;String, Integer&gt; patternOccurences,
   Map&lt;String, Set&lt;String&gt;&gt; patternWords, char guess) {
      
      Set&lt;String&gt; largestWords = new TreeSet&lt;String&gt;();
      String largestPattern = "";
      int largestSize = 0;
      int largestOccurences = 0;
      
      for (String pattern : patternWords.keySet()) {
         currentPossiblewords = patternWords.get(pattern);
         
         if ((currentPossiblewords.size() &gt; largestSize) ||
            (currentPossiblewords.size() == largestSize &amp;&amp; largestOccurences &gt; patternOccurences.get(pattern)))
         {
            largestWords = currentPossiblewords;
            largestPattern = pattern;
            largestOccurences = patternOccurences.get(pattern);
            
            if(currentPossiblewords.size() &gt; largestSize)
            largestSize = currentPossiblewords.size();
         }
         
      }
      possibleWords = largestWords;
      pattern = largestPattern;
      return largestOccurences;
   }
   
   //Private helper method
   //Receives user's guess (Assume all input character are lower-cased)
   //    Throw a IllegalStateException if attempts left is less than 1 or if the set of possible words is empty.
   //    Otherwise, throw a IllegalArgumentException if the input character was already guessed before.
   private void inputCheck(char guess) {
      if (remainingCounts &lt; 1 || possibleWords.isEmpty()) {
         throw new IllegalStateException();
      }
      if (guessedLetters.contains(guess)) {
         throw new IllegalArgumentException();
      }
      
   }
   
}
</pre>
                <pre id="originalcode" class="originalcode">import java.util.Collection;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;

//October 19, 2019
//Terry Wang
//CSE 143 Homework 4:EvilHangman
//Class Introduction:
//This class creates a HangmanManager object and some methods that
//manage the functions of a evil hangman game.

public class HangmanManager {
   private String pattern;
   private int remainingCounts;
   private int wordLength;
   private Set&lt;String&gt; possibleWords;
   private Set&lt;Character&gt; guessedLetters;
   
   //Pre: Receives a dictionary, length of word and the max attempts of guessing
   //    Throw a IllegalArgumentException if input word length &lt; 1 or max attempts &lt; 0
   //Post: Put all the words in the dictionary that match wtih the input length in a set (Eliminating duplicate)
   //    Initialize the game display as "- - - -" which '-' stands for unrevealed characters
   public HangmanManager(Collection&lt;String&gt; dictionary, int length, int max) {
      if (length &lt; 1 || max &lt; 0) {
         throw new IllegalArgumentException();
      }
      pattern = "-";
      wordLength = length;
      remainingCounts = max;
      possibleWords = new TreeSet&lt;String&gt;();
      guessedLetters = new TreeSet&lt;Character&gt;();
      
      for (String word : dictionary) {
         if (word.length() == wordLength) {
            possibleWords.add(word);
         }
      }
      for (int i = 1; i &lt; length; i++) {
         pattern += " -";
      }
      
   }
   
   //Returns the current possible set for words choices
   public Set&lt;String&gt; words() {
      return possibleWords;
   }
   
   //Returns the remaining attempts of guessing
   public int guessesLeft() {
      return remainingCounts;
   }
   
   //Returns a set which contains all the words that have been guessed
   public Set&lt;Character&gt; guesses() {
      return guessedLetters;
   }
   
   //Pre: Throw a IllegalStateException if the current possible words set is empty
   //Post: Returns the current game pattern
   public String pattern() {
      if (possibleWords.isEmpty() ) {
         throw new IllegalStateException();
      }
      return pattern;
      
   }
   //Pre: Receives user's guess (Assume all input character are lower-cased)
   //    Throw a IllegalStateException if attempts left is less than 1 or if the set of possible words is empty.
   //    Otherwise, throw a IllegalArgumentException if the input character was already guessed before.
   //Post:
   // Update the game pattern (Refers to private helper methods' comments)
   // (If guessed word occurs in pattern, update the displayed pattern from "- - - -" to "a - - n" (For example) )
   // Returns the occurences of input character in updated game pattern.
   // (If input character has no occurence in pattern, deduct 1 from remaining attempts)
   public int record(char guess) {
      
      Map&lt;String, Integer&gt; patternOccurences = new TreeMap&lt;String, Integer&gt;();
      Map&lt;String, Set&lt;String&gt;&gt; patternWords = new TreeMap&lt;String, Set&lt;String&gt;&gt;();
      Set&lt;String&gt; currentPossiblewords = new TreeSet&lt;String&gt;();
      int occurences = 0;
      
      inputCheck(guess);
      guessedLetters.add(guess);
      
      updatePattern(currentPossiblewords, patternOccurences, patternWords, guess);
      
      occurences = retrieveTheLargest(currentPossiblewords, patternOccurences, patternWords, guess);
      
      if (occurences == 0)
         remainingCounts--;
      
      return occurences;
   }
   
   //Private Helper Method
   //Pre: Receive a set of current possible word choices, the input guess,
   //    a map of pattern corresponds with the occurences of input guess
   //    and a map of pattern corresponds with possible words choices
   //Post: Based on the input guess, store all possible new game patterns and occurences of guessed chracters in those patterns
   private void updatePattern(Set&lt;String&gt; currentPossiblewords, Map&lt;String, Integer&gt; patternOccurences,
   Map&lt;String, Set&lt;String&gt;&gt; patternWords, char guess) {
      String newPattern = "";
      int occurences;
      
      for (String word : possibleWords)// goes through all the words in the current set
      {
         newPattern = pattern;
         occurences = 0;
         for (int i = 0; i &lt; wordLength; i++)// goes through each word
         {
            if (guess == word.charAt(i)) {
               occurences++;
               newPattern = newPattern.substring(0, 2 * i) + guess + newPattern.substring(2 * i + 1);
               
            }
         }
     
         if (!patternWords.containsKey(newPattern)) {
            Set&lt;String&gt; temp = new TreeSet&lt;String&gt;();
            temp.add(word);
            patternWords.put(newPattern, temp);
            patternOccurences.put(newPattern, occurences);
            
         } else {
            currentPossiblewords = patternWords.get(newPattern);
            currentPossiblewords.add(word);
         }
      }
      currentPossiblewords = new TreeSet&lt;String&gt;();
   }
   
   //Private Helper Method
   //Pre: Receive a set of current possible word choices, the input guess,
   //    a map of pattern corresponds with the occurences of input guess
   //    and a map of pattern corresponds with possible words choices
   //Post: Returns the occurences of guess from the pattern which contains the most occurences of guess
   //    (If a tie happened in words families, choose the one appeared earlier, 'A...' is prior to 'B....'
   //    Set this resulting pattern and possible words set after as the current game set.
   private int retrieveTheLargest(Set&lt;String&gt; currentPossiblewords, Map&lt;String, Integer&gt; patternOccurences,
   Map&lt;String, Set&lt;String&gt;&gt; patternWords, char guess) {
      
      Set&lt;String&gt; largestWords = new TreeSet&lt;String&gt;();
      String largestPattern = "";
      int largestSize = 0;
      int largestOccurences = 0;
      
      for (String pattern : patternWords.keySet()) {
         currentPossiblewords = patternWords.get(pattern);
         
         if ((currentPossiblewords.size() &gt; largestSize) ||
            (currentPossiblewords.size() == largestSize &amp;&amp; largestOccurences &gt; patternOccurences.get(pattern)))
         {
            largestWords = currentPossiblewords;
            largestPattern = pattern;
            largestOccurences = patternOccurences.get(pattern);
            
            if(currentPossiblewords.size() &gt; largestSize)
            largestSize = currentPossiblewords.size();
         }
         
      }
      possibleWords = largestWords;
      pattern = largestPattern;
      return largestOccurences;
   }
   
   //Private helper method
   //Receives user's guess (Assume all input character are lower-cased)
   //    Throw a IllegalStateException if attempts left is less than 1 or if the set of possible words is empty.
   //    Otherwise, throw a IllegalArgumentException if the input character was already guessed before.
   private void inputCheck(char guess) {
      if (remainingCounts &lt; 1 || possibleWords.isEmpty()) {
         throw new IllegalStateException();
      }
      if (guessedLetters.contains(guess)) {
         throw new IllegalArgumentException();
      }
      
   }
   
}
</pre>
                <pre id="homeworkcodehighlight" class="homeworkcodehighlight"><pre class="java5"><span class="kw2">import</span> <span class="co2">java.util.Collection</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.Map</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.Set</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.TreeMap</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.TreeSet</span><span class="sy0">;</span>
&nbsp;
<span class="co1">//October 19, 2019</span>
<span class="co1">//Terry Wang</span>
<span class="co1">//CSE 143 Homework 4:EvilHangman</span>
<span class="co1">//Class Introduction:</span>
<span class="co1">//This class creates a HangmanManager object and some methods that</span>
<span class="co1">//manage the functions of a evil hangman game.</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> HangmanManager <span class="br0">{</span>
   <span class="kw2">private</span> <span class="kw21">String</span> pattern<span class="sy0">;</span>
   <span class="kw2">private</span> <span class="kw3">int</span> remainingCounts<span class="sy0">;</span>
   <span class="kw2">private</span> <span class="kw3">int</span> wordLength<span class="sy0">;</span>
   <span class="kw2">private</span> <span class="kw46">Set</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span> possibleWords<span class="sy0">;</span>
   <span class="kw2">private</span> <span class="kw46">Set</span><span class="sy0">&lt;</span><span class="kw21">Character</span><span class="sy0">&gt;</span> guessedLetters<span class="sy0">;</span>
&nbsp;
   <span class="co1">//Pre: Receives a dictionary, length of word and the max attempts of guessing</span>
   <span class="co1">//    Throw a IllegalArgumentException if input word length &lt; 1 or max attempts &lt; 0</span>
   <span class="co1">//Post: Put all the words in the dictionary that match wtih the input length in a set (Eliminating duplicate)</span>
   <span class="co1">//    Initialize the game display as "- - - -" which '-' stands for unrevealed characters</span>
   <span class="kw2">public</span> HangmanManager<span class="br0">(</span><span class="kw46">Collection</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span> dictionary, <span class="kw3">int</span> length, <span class="kw3">int</span> max<span class="br0">)</span> <span class="br0">{</span>
      <span class="kw1">if</span> <span class="br0">(</span>length <span class="sy0">&lt;</span> <span class="nu0">1</span> || max <span class="sy0">&lt;</span> <span class="nu0">0</span><span class="br0">)</span> <span class="br0">{</span>
         <span class="kw2">throw</span> <span class="kw2">new</span> <span class="kw21">IllegalArgumentException</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
      pattern = <span class="st0">"-"</span><span class="sy0">;</span>
      wordLength = length<span class="sy0">;</span>
      remainingCounts = max<span class="sy0">;</span>
      possibleWords = <span class="kw2">new</span> <span class="kw46">TreeSet</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      guessedLetters = <span class="kw2">new</span> <span class="kw46">TreeSet</span><span class="sy0">&lt;</span><span class="kw21">Character</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
      <span class="kw1">for</span> <span class="br0">(</span><span class="kw21">String</span> word : dictionary<span class="br0">)</span> <span class="br0">{</span>
         <span class="kw1">if</span> <span class="br0">(</span>word.<span class="me1">length</span><span class="br0">(</span><span class="br0">)</span> == wordLength<span class="br0">)</span> <span class="br0">{</span>
            possibleWords.<span class="me1">add</span><span class="br0">(</span>word<span class="br0">)</span><span class="sy0">;</span>
         <span class="br0">}</span>
      <span class="br0">}</span>
      <span class="kw1">for</span> <span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> length<span class="sy0">;</span> i++<span class="br0">)</span> <span class="br0">{</span>
         pattern += <span class="st0">" -"</span><span class="sy0">;</span>
      <span class="br0">}</span>
&nbsp;
   <span class="br0">}</span>
&nbsp;
   <span class="co1">//Returns the current possible set for words choices</span>
   <span class="kw2">public</span> <span class="kw46">Set</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span> words<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw2">return</span> possibleWords<span class="sy0">;</span>
   <span class="br0">}</span>
&nbsp;
   <span class="co1">//Returns the remaining attempts of guessing</span>
   <span class="kw2">public</span> <span class="kw3">int</span> guessesLeft<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw2">return</span> remainingCounts<span class="sy0">;</span>
   <span class="br0">}</span>
&nbsp;
   <span class="co1">//Returns a set which contains all the words that have been guessed</span>
   <span class="kw2">public</span> <span class="kw46">Set</span><span class="sy0">&lt;</span><span class="kw21">Character</span><span class="sy0">&gt;</span> guesses<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw2">return</span> guessedLetters<span class="sy0">;</span>
   <span class="br0">}</span>
&nbsp;
   <span class="co1">//Pre: Throw a IllegalStateException if the current possible words set is empty</span>
   <span class="co1">//Post: Returns the current game pattern</span>
   <span class="kw2">public</span> <span class="kw21">String</span> pattern<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw1">if</span> <span class="br0">(</span>possibleWords.<span class="me1">isEmpty</span><span class="br0">(</span><span class="br0">)</span> <span class="br0">)</span> <span class="br0">{</span>
         <span class="kw2">throw</span> <span class="kw2">new</span> <span class="kw21">IllegalStateException</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw2">return</span> pattern<span class="sy0">;</span>
&nbsp;
   <span class="br0">}</span>
   <span class="co1">//Pre: Receives user's guess (Assume all input character are lower-cased)</span>
   <span class="co1">//    Throw a IllegalStateException if attempts left is less than 1 or if the set of possible words is empty.</span>
   <span class="co1">//    Otherwise, throw a IllegalArgumentException if the input character was already guessed before.</span>
   <span class="co1">//Post:</span>
   <span class="co1">// Update the game pattern (Refers to private helper methods' comments)</span>
   <span class="co1">// (If guessed word occurs in pattern, update the displayed pattern from "- - - -" to "a - - n" (For example) )</span>
   <span class="co1">// Returns the occurences of input character in updated game pattern.</span>
   <span class="co1">// (If input character has no occurence in pattern, deduct 1 from remaining attempts)</span>
   <span class="kw2">public</span> <span class="kw3">int</span> record<span class="br0">(</span><span class="kw3">char</span> guess<span class="br0">)</span> <span class="br0">{</span>
&nbsp;
      <span class="kw46">Map</span><span class="sy0">&lt;</span><span class="kw21">String</span>, <span class="kw21">Integer</span><span class="sy0">&gt;</span> patternOccurences = <span class="kw2">new</span> <span class="kw46">TreeMap</span><span class="sy0">&lt;</span><span class="kw21">String</span>, <span class="kw21">Integer</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw46">Map</span><span class="sy0">&lt;</span><span class="kw21">String</span>, <span class="kw46">Set</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;&gt;</span> patternWords = <span class="kw2">new</span> <span class="kw46">TreeMap</span><span class="sy0">&lt;</span><span class="kw21">String</span>, <span class="kw46">Set</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw46">Set</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span> currentPossiblewords = <span class="kw2">new</span> <span class="kw46">TreeSet</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">int</span> occurences = <span class="nu0">0</span><span class="sy0">;</span>
&nbsp;
      inputCheck<span class="br0">(</span>guess<span class="br0">)</span><span class="sy0">;</span>
      guessedLetters.<span class="me1">add</span><span class="br0">(</span>guess<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
      updatePattern<span class="br0">(</span>currentPossiblewords, patternOccurences, patternWords, guess<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
      occurences = retrieveTheLargest<span class="br0">(</span>currentPossiblewords, patternOccurences, patternWords, guess<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
      <span class="kw1">if</span> <span class="br0">(</span>occurences == <span class="nu0">0</span><span class="br0">)</span>
         remainingCounts--<span class="sy0">;</span>
&nbsp;
      <span class="kw2">return</span> occurences<span class="sy0">;</span>
   <span class="br0">}</span>
&nbsp;
   <span class="co1">//Private Helper Method</span>
   <span class="co1">//Pre: Receive a set of current possible word choices, the input guess,</span>
   <span class="co1">//    a map of pattern corresponds with the occurences of input guess</span>
   <span class="co1">//    and a map of pattern corresponds with possible words choices</span>
   <span class="co1">//Post: Based on the input guess, store all possible new game patterns and occurences of guessed chracters in those patterns</span>
   <span class="kw2">private</span> <span class="kw3">void</span> updatePattern<span class="br0">(</span><span class="kw46">Set</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span> currentPossiblewords, <span class="kw46">Map</span><span class="sy0">&lt;</span><span class="kw21">String</span>, <span class="kw21">Integer</span><span class="sy0">&gt;</span> patternOccurences,
   <span class="kw46">Map</span><span class="sy0">&lt;</span><span class="kw21">String</span>, <span class="kw46">Set</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;&gt;</span> patternWords, <span class="kw3">char</span> guess<span class="br0">)</span> <span class="br0">{</span>
      <span class="kw21">String</span> newPattern = <span class="st0">""</span><span class="sy0">;</span>
      <span class="kw3">int</span> occurences<span class="sy0">;</span>
&nbsp;
      <span class="kw1">for</span> <span class="br0">(</span><span class="kw21">String</span> word : possibleWords<span class="br0">)</span><span class="co1">// goes through all the words in the current set</span>
      <span class="br0">{</span>
         newPattern = pattern<span class="sy0">;</span>
         occurences = <span class="nu0">0</span><span class="sy0">;</span>
         <span class="kw1">for</span> <span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> wordLength<span class="sy0">;</span> i++<span class="br0">)</span><span class="co1">// goes through each word</span>
         <span class="br0">{</span>
            <span class="kw1">if</span> <span class="br0">(</span>guess == word.<span class="me1">charAt</span><span class="br0">(</span>i<span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
               occurences++<span class="sy0">;</span>
               newPattern = newPattern.<span class="me1">substring</span><span class="br0">(</span><span class="nu0">0</span>, <span class="nu0">2</span> <span class="sy0">*</span> i<span class="br0">)</span> + guess + newPattern.<span class="me1">substring</span><span class="br0">(</span><span class="nu0">2</span> <span class="sy0">*</span> i + <span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
            <span class="br0">}</span>
         <span class="br0">}</span>
&nbsp;
         <span class="kw1">if</span> <span class="br0">(</span><span class="sy0">!</span>patternWords.<span class="me1">containsKey</span><span class="br0">(</span>newPattern<span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
            <span class="kw46">Set</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span> temp = <span class="kw2">new</span> <span class="kw46">TreeSet</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
            temp.<span class="me1">add</span><span class="br0">(</span>word<span class="br0">)</span><span class="sy0">;</span>
            patternWords.<span class="me1">put</span><span class="br0">(</span>newPattern, temp<span class="br0">)</span><span class="sy0">;</span>
            patternOccurences.<span class="me1">put</span><span class="br0">(</span>newPattern, occurences<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
         <span class="br0">}</span> <span class="kw1">else</span> <span class="br0">{</span>
            currentPossiblewords = patternWords.<span class="me1">get</span><span class="br0">(</span>newPattern<span class="br0">)</span><span class="sy0">;</span>
            currentPossiblewords.<span class="me1">add</span><span class="br0">(</span>word<span class="br0">)</span><span class="sy0">;</span>
         <span class="br0">}</span>
      <span class="br0">}</span>
      currentPossiblewords = <span class="kw2">new</span> <span class="kw46">TreeSet</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
   <span class="br0">}</span>
&nbsp;
   <span class="co1">//Private Helper Method</span>
   <span class="co1">//Pre: Receive a set of current possible word choices, the input guess,</span>
   <span class="co1">//    a map of pattern corresponds with the occurences of input guess</span>
   <span class="co1">//    and a map of pattern corresponds with possible words choices</span>
   <span class="co1">//Post: Returns the occurences of guess from the pattern which contains the most occurences of guess</span>
   <span class="co1">//    (If a tie happened in words families, choose the one appeared earlier, 'A...' is prior to 'B....'</span>
   <span class="co1">//    Set this resulting pattern and possible words set after as the current game set.</span>
   <span class="kw2">private</span> <span class="kw3">int</span> retrieveTheLargest<span class="br0">(</span><span class="kw46">Set</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span> currentPossiblewords, <span class="kw46">Map</span><span class="sy0">&lt;</span><span class="kw21">String</span>, <span class="kw21">Integer</span><span class="sy0">&gt;</span> patternOccurences,
   <span class="kw46">Map</span><span class="sy0">&lt;</span><span class="kw21">String</span>, <span class="kw46">Set</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;&gt;</span> patternWords, <span class="kw3">char</span> guess<span class="br0">)</span> <span class="br0">{</span>
&nbsp;
      <span class="kw46">Set</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span> largestWords = <span class="kw2">new</span> <span class="kw46">TreeSet</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw21">String</span> largestPattern = <span class="st0">""</span><span class="sy0">;</span>
      <span class="kw3">int</span> largestSize = <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw3">int</span> largestOccurences = <span class="nu0">0</span><span class="sy0">;</span>
&nbsp;
      <span class="kw1">for</span> <span class="br0">(</span><span class="kw21">String</span> pattern : patternWords.<span class="me1">keySet</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
         currentPossiblewords = patternWords.<span class="me1">get</span><span class="br0">(</span>pattern<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
         <span class="kw1">if</span> <span class="br0">(</span><span class="br0">(</span>currentPossiblewords.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span> <span class="sy0">&gt;</span> largestSize<span class="br0">)</span> ||
            <span class="br0">(</span>currentPossiblewords.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span> == largestSize <span class="sy0">&amp;&amp;</span> largestOccurences <span class="sy0">&gt;</span> patternOccurences.<span class="me1">get</span><span class="br0">(</span>pattern<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
         <span class="br0">{</span>
            largestWords = currentPossiblewords<span class="sy0">;</span>
            largestPattern = pattern<span class="sy0">;</span>
            largestOccurences = patternOccurences.<span class="me1">get</span><span class="br0">(</span>pattern<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
            <span class="kw1">if</span><span class="br0">(</span>currentPossiblewords.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span> <span class="sy0">&gt;</span> largestSize<span class="br0">)</span>
            largestSize = currentPossiblewords.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
         <span class="br0">}</span>
&nbsp;
      <span class="br0">}</span>
      possibleWords = largestWords<span class="sy0">;</span>
      pattern = largestPattern<span class="sy0">;</span>
      <span class="kw2">return</span> largestOccurences<span class="sy0">;</span>
   <span class="br0">}</span>
&nbsp;
   <span class="co1">//Private helper method</span>
   <span class="co1">//Receives user's guess (Assume all input character are lower-cased)</span>
   <span class="co1">//    Throw a IllegalStateException if attempts left is less than 1 or if the set of possible words is empty.</span>
   <span class="co1">//    Otherwise, throw a IllegalArgumentException if the input character was already guessed before.</span>
   <span class="kw2">private</span> <span class="kw3">void</span> inputCheck<span class="br0">(</span><span class="kw3">char</span> guess<span class="br0">)</span> <span class="br0">{</span>
      <span class="kw1">if</span> <span class="br0">(</span>remainingCounts <span class="sy0">&lt;</span> <span class="nu0">1</span> || possibleWords.<span class="me1">isEmpty</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
         <span class="kw2">throw</span> <span class="kw2">new</span> <span class="kw21">IllegalStateException</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw1">if</span> <span class="br0">(</span>guessedLetters.<span class="me1">contains</span><span class="br0">(</span>guess<span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
         <span class="kw2">throw</span> <span class="kw2">new</span> <span class="kw21">IllegalArgumentException</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
&nbsp;
   <span class="br0">}</span>
&nbsp;
<span class="br0">}</span>
&nbsp;</pre></pre>
                <pre id="homeworkcodeoverlay" class="homeworkcodeoverlay" style="color: transparent;">import java.util.Collection;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;

//October 19, 2019
//Terry Wang
//CSE 143 Homework 4:EvilHangman
//Class Introduction:
//This class creates a HangmanManager object and some methods that
//manage the functions of a evil hangman game.

public class HangmanManager {
   private String pattern;
   private int remainingCounts;
   private int wordLength;
   private Set&lt;String&gt; possibleWords;
   private Set&lt;Character&gt; guessedLetters;
   
   //Pre: Receives a dictionary, length of word and the max attempts of guessing
   //    Throw a IllegalArgumentException if input word length &lt; 1 or max attempts &lt; 0
   //Post: Put all the words in the dictionary that match wtih the input length in a set (Eliminating duplicate)
   //    Initialize the game display as "- - - -" which '-' stands for unrevealed characters
   public HangmanManager(Collection&lt;String&gt; dictionary, int length, int max) {
      if (length &lt; 1 || max &lt; 0) {
         throw new IllegalArgumentException();
      }
      pattern = "-";
      wordLength = length;
      remainingCounts = max;
      possibleWords = new TreeSet&lt;String&gt;();
      guessedLetters = new TreeSet&lt;Character&gt;();
      
      for (String word : dictionary) {
         if (word.length() == wordLength) {
            possibleWords.add(word);
         }
      }
      for (int i = 1; i &lt; length; i++) {
         pattern += " -";
      }
      
   }
   
   //Returns the current possible set for words choices
   public Set&lt;String&gt; words() {
      return possibleWords;
   }
   
   //Returns the remaining attempts of guessing
   public int guessesLeft() {
      return remainingCounts;
   }
   
   //Returns a set which contains all the words that have been guessed
   public Set&lt;Character&gt; guesses() {
      return guessedLetters;
   }
   
   //Pre: Throw a IllegalStateException if the current possible words set is empty
   //Post: Returns the current game pattern
   public String pattern() {
      if (possibleWords.isEmpty() ) {
         throw new IllegalStateException();
      }
      return pattern;
      
   }
   //Pre: Receives user's guess (Assume all input character are lower-cased)
   //    Throw a IllegalStateException if attempts left is less than 1 or if the set of possible words is empty.
   //    Otherwise, throw a IllegalArgumentException if the input character was already guessed before.
   //Post:
   // Update the game pattern (Refers to private helper methods' comments)
   // (If guessed word occurs in pattern, update the displayed pattern from "- - - -" to "a - - n" (For example) )
   // Returns the occurences of input character in updated game pattern.
   // (If input character has no occurence in pattern, deduct 1 from remaining attempts)
   public int record(char guess) {
      
      Map&lt;String, Integer&gt; patternOccurences = new TreeMap&lt;String, Integer&gt;();
      Map&lt;String, Set&lt;String&gt;&gt; patternWords = new TreeMap&lt;String, Set&lt;String&gt;&gt;();
      Set&lt;String&gt; currentPossiblewords = new TreeSet&lt;String&gt;();
      int occurences = 0;
      
      inputCheck(guess);
      guessedLetters.add(guess);
      
      updatePattern(currentPossiblewords, patternOccurences, patternWords, guess);
      
      occurences = retrieveTheLargest(currentPossiblewords, patternOccurences, patternWords, guess);
      
      if (occurences == 0)
         remainingCounts--;
      
      return occurences;
   }
   
   //Private Helper Method
   //Pre: Receive a set of current possible word choices, the input guess,
   //    a map of pattern corresponds with the occurences of input guess
   //    and a map of pattern corresponds with possible words choices
   //Post: Based on the input guess, store all possible new game patterns and occurences of guessed chracters in those patterns
   private void updatePattern(Set&lt;String&gt; currentPossiblewords, Map&lt;String, Integer&gt; patternOccurences,
   Map&lt;String, Set&lt;String&gt;&gt; patternWords, char guess) {
      String newPattern = "";
      int occurences;
      
      for (String word : possibleWords)// goes through all the words in the current set
      {
         newPattern = pattern;
         occurences = 0;
         for (int i = 0; i &lt; wordLength; i++)// goes through each word
         {
            if (guess == word.charAt(i)) {
               occurences++;
               newPattern = newPattern.substring(0, 2 * i) + guess + newPattern.substring(2 * i + 1);
               
            }
         }
     
         if (!patternWords.containsKey(newPattern)) {
            Set&lt;String&gt; temp = new TreeSet&lt;String&gt;();
            temp.add(word);
            patternWords.put(newPattern, temp);
            patternOccurences.put(newPattern, occurences);
            
         } else {
            currentPossiblewords = patternWords.get(newPattern);
            currentPossiblewords.add(word);
         }
      }
      currentPossiblewords = new TreeSet&lt;String&gt;();
   }
   
   //Private Helper Method
   //Pre: Receive a set of current possible word choices, the input guess,
   //    a map of pattern corresponds with the occurences of input guess
   //    and a map of pattern corresponds with possible words choices
   //Post: Returns the occurences of guess from the pattern which contains the most occurences of guess
   //    (If a tie happened in words families, choose the one appeared earlier, 'A...' is prior to 'B....'
   //    Set this resulting pattern and possible words set after as the current game set.
   private int retrieveTheLargest(Set&lt;String&gt; currentPossiblewords, Map&lt;String, Integer&gt; patternOccurences,
   Map&lt;String, Set&lt;String&gt;&gt; patternWords, char guess) {
      
      Set&lt;String&gt; largestWords = new TreeSet&lt;String&gt;();
      String largestPattern = "";
      int largestSize = 0;
      int largestOccurences = 0;
      
      for (String pattern : patternWords.keySet()) {
         currentPossiblewords = patternWords.get(pattern);
         
         if ((currentPossiblewords.size() &gt; largestSize) ||
            (currentPossiblewords.size() == largestSize &amp;&amp; largestOccurences &gt; patternOccurences.get(pattern)))
         {
            largestWords = currentPossiblewords;
            largestPattern = pattern;
            largestOccurences = patternOccurences.get(pattern);
            
            if(currentPossiblewords.size() &gt; largestSize)
            largestSize = currentPossiblewords.size();
         }
         
      }
      possibleWords = largestWords;
      pattern = largestPattern;
      return largestOccurences;
   }
   
   //Private helper method
   //Receives user's guess (Assume all input character are lower-cased)
   //    Throw a IllegalStateException if attempts left is less than 1 or if the set of possible words is empty.
   //    Otherwise, throw a IllegalArgumentException if the input character was already guessed before.
   private void inputCheck(char guess) {
      if (remainingCounts &lt; 1 || possibleWords.isEmpty()) {
         throw new IllegalStateException();
      }
      if (guessedLetters.contains(guess)) {
         throw new IllegalArgumentException();
      }
      
   }
   
}
</pre>
                <span class="studentparam">JUNTIW3</span>
                <span class="filenameparam">HangmanManager.java</span>
            </div> <span style="visibility: hidden;">&nbsp;</span>
        </td>
    </tr>
</tbody></table>

            </div>


    <div id="loading"></div>
    <pre id="dumptarget"></pre>

    
            <script src="./Grade-It - Score Report_ 143 19au a4 DC JUNTIW3_files/additional.js.download" type="text/javascript"></script>

            
    


</body></html>
